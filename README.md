# 100 D√≠as de IA

| Libros y Recursos | Estado de Finalizaci√≥n |
| ----- | -----|
| 1. [**Machine Learning Specialization**](https://www.coursera.org/specializations/machine-learning-introduction?page=1) | ‚úÖ |
| 2. [**Deep Learning Specialization**](https://www.coursera.org/specializations/deep-learning?)| ‚úÖ  |
| 3. [**IA generativa con grandes modelos ling√º√≠sticos**](https://www.coursera.org/learn/generative-ai-with-llms/) | ‚úÖ |
| 4. [**Curso de Deep Learning**](https://youtube.com/playlist?list=PLcfxtMhW8iFNMTFKrYMYYzVTNzu-xG-Ys&si=lqAlbDIhtOJ5zMP8) | ‚úÖ |
| 5. [**Computer Vision**](https://youtube.com/playlist?list=PLISuMnTdVU-yvm6X7SwKtUosfr4ZarStU&si=FOMUjJ5SvotgMhHW) | ‚úÖ |

| Proyectos Completados |
| ----------------- |
| [1. Clasificaci√≥n de Flores Iris](https://colab.research.google.com/drive/1Qv7LRrhvzGuJPkelYWz9zYJz-oPYIqDJ?usp=sharing)  |
| [2. Hola Mundo (Deep Learning)](https://colab.research.google.com/drive/1jokMDImAKHwhucMxo6ZW1Cs2OXlHUpyR?usp=sharing) |
| [3. Clasificador de perros y gatos](https://colab.research.google.com/drive/1Efva3sau54WHusFRnfcFxL-9sLuO27L0) |
| 4.  |

# Temas Cubiertos en Cada D√≠a
| **D√≠as** | **Temas Cubiertos** | 
|--------- | ------------------ |
| [D√≠a1](#D√≠a1) | Introducci√≥n a Deep Learning | 
| [D√≠a2](#D√≠a2) | Historia y Evoluci√≥n de Deep Learning | 
| [D√≠a3](#D√≠a3) | Breve Descripci√≥n de las Diferentes T√©cnicas en Deep Learning | 
| [D√≠a4](#D√≠a4) | Comparaci√≥n y Aplicaciones de T√©cnicas de Deep Learning en el Mundo Real | 
| [D√≠a5](#D√≠a5) | Redes Neuronales Artificiales (ANNs) | 
| [D√≠a6](#D√≠a6) | Forward y Backward Propagation | 
| [D√≠a7](#D√≠a7) | Coste y Funciones de P√©rdida | 
| [D√≠a8](#D√≠a8) | Algoritmos de Optimizaci√≥n | 
| [D√≠a9](#D√≠a9) | Overfitting y T√©cnicas de Regularizaci√≥n | 
| [D√≠a10](#D√≠a10) | Construyendo una Red Neuronal desde Cero: Clasificaci√≥n de Flores Iris | 
| [D√≠a11](#D√≠a11) | Construyendo una Red Neuronal con Tensorflow: Clasificaci√≥n de Digitos Escritos a Mano | 
| [D√≠a12](#D√≠a12) | Redes Neuronales Profundas | 
| [D√≠a13](#D√≠a13) | Conceptos b√°sicos y arquitectura general de las CNNs | 
| [D√≠a14](#D√≠a14) | ¬øC√≥mo funcionan las CNNs en comparaci√≥n con las ANNs? | 
| [D√≠a15](#D√≠a15) | Ejemplos Pr√°cticos de Aplicaci√≥n en la Industria | 
| [D√≠a16](#D√≠a16) | Comprendiendo la Convoluci√≥n en Im√°genes | 
| [D√≠a17](#D√≠a17) | Entendiendo los Filtros y su Papel en la Extracci√≥n de Caracter√≠sticas | 
| [D√≠a18](#D√≠a18) | Stride y Padding en CNNs | 
| [D√≠a19](#D√≠a19) | Pooling en CNNs | 
| [D√≠a20](#D√≠a20) | Funciones de Activaci√≥n | 
| [D√≠a21](#D√≠a21) | Construcci√≥n de Capas en CNNs | 
| [D√≠a22](#D√≠a22) | Capas Completamente Conectadas (Fully Connected Layers) | 
| [D√≠a23](#D√≠a23) | Regularizaci√≥n en CNNs | 
| [D√≠a24](#D√≠a24) | Backpropagation en CNNs | 
| [D√≠a25](#D√≠a25) | Actualizaci√≥n de Pesos y Ajuste de Filtros | 
| [D√≠a26](#D√≠a26) | Clasificador de perros y gatos | 
| [D√≠a27](#D√≠a27) | Explorando arquitecturas influyentes en el aprendizaje profundo | 
| [D√≠a28](#D√≠a28) | Arquitecturas Espec√≠ficas en Visi√≥n por Computadora | 
| [D√≠a29](#D√≠a29) | Concepto de Transfer Learning | 
| [D√≠a30](#D√≠a30) | T√©cnicas de Transfer Learning | 
| [D√≠a31](#D√≠a31) | Detecci√≥n de Objetos | 
| [D√≠a32](#D√≠a32) | Evoluci√≥n de YOLO: Desde 2015 hasta 2024 | 
| [D√≠a33](#D√≠a33) | YOLOv8 y sus Variantes con Ultralytics | 
| [D√≠a34](#D√≠a34) | Aplicaciones Avanzadas de Detecci√≥n de Objetos | 
| [D√≠a35](#D√≠a35) | T√©cnicas de Mejora de Precisi√≥n en Detecci√≥n de Objetos | 
| [D√≠a36](#D√≠a36) | Segmentaci√≥n de Im√°genes | 
| [D√≠a37](#D√≠a37) | Implementaci√≥n de Segmentaci√≥n de Im√°genes con YOLO | 
| [D√≠a38](#D√≠a38) | Introducci√≥n a los Modelos Preentrenados | 
| [D√≠a39](#D√≠a39) |  | 
| [D√≠a40](#D√≠a40) |  | 
| [D√≠a41](#D√≠a41) |  | 
| [D√≠a42](#D√≠a42) |  | 
| [D√≠a43](#D√≠a43) |  | 
| [D√≠a44](#D√≠a44) |  | 
| [D√≠a45](#D√≠a45) |  | 
| [D√≠a46](#D√≠a46) |  | 
| [D√≠a47](#D√≠a47) |  | 
| [D√≠a48](#D√≠a48) |  | 
| [D√≠a49](#D√≠a49) |  | 
| [D√≠a50](#D√≠a50) |  | 
| [D√≠a51](#D√≠a51) |  | 
| [D√≠a52](#D√≠a52) |  | 
| [D√≠a53](#D√≠a53) |  | 
| [D√≠a54](#D√≠a54) |  | 
| [D√≠a55](#D√≠a55) |  | 
| [D√≠a56](#D√≠a56) |  | 
| [D√≠a57](#D√≠a57) |  | 
| [D√≠a58](#D√≠a58) |  | 
| [D√≠a59](#D√≠a59) |  | 
| [D√≠a60](#D√≠a60) |  | 
| [D√≠a61](#D√≠a61) |  | 
| [D√≠a62](#D√≠a62) |  | 
| [D√≠a63](#D√≠a63) |  | 
| [D√≠a64](#D√≠a64) |  | 
| [D√≠a65](#D√≠a65) |  | 
| [D√≠a66](#D√≠a66) |  | 
| [D√≠a67](#D√≠a67) |  | 
| [D√≠a68](#D√≠a68) |  | 
| [D√≠a69](#D√≠a69) |  | 
| [D√≠a70](#D√≠a70) |  | 
| [D√≠a71](#D√≠a71) |  | 
| [D√≠a72](#D√≠a72) |  | 
| [D√≠a73](#D√≠a73) |  | 
| [D√≠a74](#D√≠a74) |  | 
| [D√≠a75](#D√≠a75) |  | 
| [D√≠a76](#D√≠a76) |  | 
| [D√≠a77](#D√≠a77) |  | 
| [D√≠a78](#D√≠a78) |  | 
| [D√≠a79](#D√≠a79) |  | 
| [D√≠a80](#D√≠a80) |  | 
| [D√≠a81](#D√≠a81) |  | 
| [D√≠a82](#D√≠a82) |  | 
| [D√≠a83](#D√≠a83) |  | 
| [D√≠a84](#D√≠a84) |  | 
| [D√≠a85](#D√≠a85) |  | 
| [D√≠a86](#D√≠a86) |  | 
| [D√≠a87](#D√≠a87) |  | 
| [D√≠a88](#D√≠a88) |  | 
| [D√≠a89](#D√≠a89) |  | 
| [D√≠a90](#D√≠a90) |  | 
| [D√≠a91](#D√≠a91) |  | 
| [D√≠a92](#D√≠a92) |  | 
| [D√≠a93](#D√≠a93) |  | 
| [D√≠a94](#D√≠a94) |  | 
| [D√≠a95](#D√≠a95) |  | 
| [D√≠a96](#D√≠a96) |  | 
| [D√≠a97](#D√≠a97) |  | 
| [D√≠a98](#D√≠a98) |  | 
| [D√≠a99](#D√≠a99) |  | 
| [D√≠a100](#D√≠a100) |  | 

# D√≠a1
---
## Introducci√≥n a Deep Learning üåü

¬°Bienvenidos al primer d√≠a de mi viaje de 100 d√≠as explorando la Inteligencia Artificial! üöÄ Hoy comenzamos con **Deep Learning**.

### ¬øQu√© es Deep Learning?

Deep Learning, o Aprendizaje Profundo, es una rama avanzada del **Machine Learning** que se inspira en la estructura y funci√≥n del cerebro humano. Utiliza **redes neuronales artificiales** para aprender de grandes vol√∫menes de datos y tomar decisiones o hacer predicciones precisas.

### ¬øPor qu√© es importante?

En los √∫ltimos a√±os, el Deep Learning ha revolucionado muchas industrias. Desde la **visi√≥n por computadora** que permite a los veh√≠culos aut√≥nomos ver el mundo, hasta el **procesamiento de lenguaje natural** que ayuda a las m√°quinas a entender y responder en lenguaje humano. Deep Learning es la tecnolog√≠a detr√°s de innovaciones impresionantes que est√°n cambiando la forma en que interactuamos con el mundo digital.

### ¬øC√≥mo funciona?

Las redes neuronales profundas est√°n compuestas por capas de neuronas artificiales. Cada capa transforma la entrada de datos en algo m√°s √∫til para la siguiente capa. A trav√©s de un proceso de entrenamiento, estas redes aprenden a extraer caracter√≠sticas complejas y patrones directamente de los datos.

### Ejemplos de Aplicaciones de Deep Learning:

- **Reconocimiento de Im√°genes**: Identificar objetos y personas en fotos y videos.
- **Traducci√≥n Autom√°tica**: Convertir texto de un idioma a otro con gran precisi√≥n.
- **Diagn√≥stico M√©dico**: Analizar im√°genes m√©dicas para detectar enfermedades.



 **Recursos para comenzar**üß†:
- **[APRENDIZAJE PROFUNDO EN INTELIGENCIA ARTIFICIAL](https://youtu.be/Zcb8R2TF3bI?si=f1NIEJgXh7cWdadV)** - Una breve esplicacion dew que es deep learning.
- **[¬øQUE ES EL DEEP LEARNING? - EXPLICADO MUY FACIL](https://youtu.be/s0SbvGiG28w?si=Rr51xld8H8ilsrz9)** - Video de Dalto explicando que es deep learning.
- **[¬øQu√© son el MACHINE LEARNING y el DEEP LEARNING?](https://youtu.be/HMEjoBnCc9c?si=U5MXn98cY7Yovy8w)** - Diferencias entre el Machine Learning y el Deep Learning.
- **[¬øDe qu√© es capaz la inteligencia artificial? ](https://youtu.be/34Kz-PP_X7c?si=sbV0ENQYtvT2JKiI)** - Documental de DW.

¬°√önete a m√≠ en este emocionante viaje y no dudes en compartir tus pensamientos y preguntas! üöÄ

---
# D√≠a2
---
## Historia y Evoluci√≥n de Deep Learning üìú

¬°Bienvenidos al segundo d√≠a de nuestra traves√≠a de 100 d√≠as en el mundo de la Inteligencia Artificial! Hoy, exploramos la fascinante **historia y evoluci√≥n de Deep Learning**. üåü

### Or√≠genes y Primeros Pasos

#### 1943: La Idea de una Neurona Artificial üí°
El viaje de Deep Learning comenz√≥ con Warren McCulloch y Walter Pitts, quienes propusieron el primer modelo matem√°tico de una **neurona artificial**. Su trabajo sent√≥ las bases para las redes neuronales, sugiriendo que las neuronas podr√≠an ser el equivalente funcional de un interruptor binario.

#### 1958: El Perceptr√≥n ü§ñ
Frank Rosenblatt desarroll√≥ el **Perceptr√≥n**, el primer modelo de red neuronal capaz de aprender. El perceptr√≥n es un tipo simple de red que puede clasificar datos en dos categor√≠as. Aunque su capacidad era limitada, fue un hito importante que inspir√≥ investigaciones futuras.

### El Invierno de la IA ‚ùÑÔ∏è

#### A√±os 70-80: Desaf√≠os y Dudas
Durante los a√±os 70 y 80, las expectativas sobre las redes neuronales no se cumplieron, y la falta de poder computacional y datos llev√≥ a lo que se conoce como el **"invierno de la IA"**. Durante este per√≠odo, la investigaci√≥n en redes neuronales se desaceler√≥ debido al escepticismo y la falta de avances significativos.

### Renacimiento y Avances üöÄ

#### 1986: El Redescubrimiento de la Propagaci√≥n hacia Atr√°s
En 1986, David Rumelhart, Geoffrey Hinton y Ronald Williams revitalizaron el inter√©s en las redes neuronales con su trabajo sobre la **retropropagaci√≥n**. Este algoritmo permiti√≥ el entrenamiento eficaz de redes neuronales multicapa, allanando el camino para el desarrollo de modelos m√°s complejos.

#### A√±os 90: Aplicaciones Pr√°cticas üåê
A medida que aumentaba el poder computacional y se dispon√≠a de m√°s datos, las redes neuronales comenzaron a mostrar su potencial en √°reas como el reconocimiento de patrones y la predicci√≥n financiera. Sin embargo, a√∫n quedaban desaf√≠os significativos por superar.

### La Era de Deep Learning üí•

#### 2006: El Avance de las Redes Profundas
Geoffrey Hinton y su equipo introdujeron el concepto de **preentrenamiento de capas** en redes profundas, lo que permiti√≥ entrenar eficientemente modelos con muchas capas. Este avance marc√≥ el comienzo de la **era de Deep Learning**, demostrando que las redes neuronales profundas pod√≠an superar a los m√©todos tradicionales en tareas complejas.

#### 2012: El Triunfo en ImageNet üèÜ
El hito crucial lleg√≥ en 2012 cuando una red profunda conocida como **AlexNet**, desarrollada por Alex Krizhevsky, Ilya Sutskever y Geoffrey Hinton, gan√≥ el desaf√≠o de reconocimiento de im√°genes de **ImageNet** con un margen significativo. Esto consolid√≥ a Deep Learning como la tecnolog√≠a l√≠der en visi√≥n por computadora.

### Transformadores y Nuevas Fronteras üöÄ

#### 2017: El Surgimiento de los Transformadores
En 2017, el art√≠culo "Attention is All You Need" de Google introdujo el **modelo Transformer**, revolucionando el procesamiento del lenguaje natural (NLP). Los Transformers, como **BERT** y **GPT**, demostraron capacidades impresionantes en tareas de lenguaje, superando a los modelos anteriores.

#### 2018: GPT y el Avance de los Modelos de Lenguaje
OpenAI lanz√≥ **GPT (Generative Pre-trained Transformer)**, seguido por GPT-2 y el famoso **GPT-3** en 2020. Estos modelos mostraron habilidades sin precedentes en generaci√≥n de texto, comprensi√≥n y traducci√≥n, marcando un hito en el desarrollo de la IA.

### Innovaciones Recientes üîÑ

#### 2021: DALL-E y la Creatividad Artificial
OpenAI present√≥ **DALL-E**, un modelo capaz de generar im√°genes a partir de descripciones textuales. Esta innovaci√≥n destac√≥ la capacidad de la IA para combinar lenguaje y visi√≥n, abriendo nuevas posibilidades en arte y dise√±o.

#### 2021: AlphaFold y la Revoluci√≥n en la Biolog√≠a
DeepMind's **AlphaFold** resolvi√≥ uno de los mayores desaf√≠os en biolog√≠a: la predicci√≥n de estructuras proteicas. Este avance promete acelerar el descubrimiento de medicamentos y mejorar nuestra comprensi√≥n de la biolog√≠a molecular.

#### 2022: ChatGPT y la Conversaci√≥n Natural
OpenAI lanz√≥ **ChatGPT**, una versi√≥n mejorada de GPT-3 optimizada para conversaciones interactivas. Este modelo demostr√≥ habilidades avanzadas en el di√°logo, respondiendo preguntas y asistiendo en diversas tareas de manera coherente y precisa.


### Recursos para Explorar M√°s:

- **[Breve Historia de las Redes Neuronales Artificiales](https://www.aprendemachinelearning.com/breve-historia-de-las-redes-neuronales-artificiales/)** - Un art√≠culo detallado sobre la evoluci√≥n de las redes neuronales.
- **[The brief history of artificial intelligence](https://ourworldindata.org/brief-history-of-ai)** - Un art√≠culo detallado sobre la evoluci√≥n de la IA.

### Evoluci√≥n de los modelos de IA con respecto a la computaci√≥n utilizada en su entrenamiento

<<<<<<< HEAD
=======
https://github.com/Oliver369X/100DaysOfAI/assets/110129950/64c6b46d-4c12-4e7a-8511-b35a2ad5be8e

>>>>>>> 52f223851c1f64cb143e7b84519e39d23a2985f8
---
# D√≠a3
---
## Breve Descripci√≥n de las Diferentes T√©cnicas en Deep Learning üß†


### 1. Redes Neuronales Convolucionales (CNN) üñºÔ∏è

#### Descripci√≥n
Las **Redes Neuronales Convolucionales (CNN)** est√°n dise√±adas para procesar datos con una estructura de grilla, como las im√°genes. Utilizan capas convolucionales que aplican filtros para detectar caracter√≠sticas como bordes, texturas y patrones en las im√°genes.

#### Componentes Clave
- **Capas Convolucionales**: Aplican filtros para extraer caracter√≠sticas locales.
- **Capas de Pooling**: Reducen la dimensionalidad y ayudan a generalizar.
- **Capas Completamente Conectadas**: Usadas para clasificar y tomar decisiones basadas en las caracter√≠sticas extra√≠das.

### 2. Redes Neuronales Recurrentes (RNN) üîÅ

#### Descripci√≥n
Las **Redes Neuronales Recurrentes (RNN)** est√°n dise√±adas para procesar secuencias de datos, como texto o series temporales. Tienen conexiones recurrentes que permiten que la informaci√≥n persista, lo que es √∫til para modelar dependencias temporales.

#### Componentes Clave
- **Celdas Recurrentes**: Mantienen un estado oculto que captura informaci√≥n de pasos anteriores.
- **LSTM y GRU**: Variantes avanzadas de RNN que abordan problemas de memoria a largo plazo.

### 3. Redes Generativas Adversariales (GAN) üé®

#### Descripci√≥n
Las **Redes Generativas Adversariales (GAN)** constan de dos redes: una generadora y una discriminadora. La generadora crea datos falsos, mientras que la discriminadora intenta distinguir entre datos reales y falsos. Este proceso competitivo mejora la capacidad de la generadora para producir datos realistas.

#### Componentes Clave
- **Generador**: Crea datos sint√©ticos.
- **Discriminador**: Distingue entre datos reales y generados.
- **Juego Adversarial**: La competencia entre las dos redes mejora el rendimiento del sistema.

### 4. Transformadores üîÑ

#### Descripci√≥n
Los **Transformadores** han revolucionado el procesamiento del lenguaje natural (NLP) con su mecanismo de atenci√≥n que permite procesar todas las palabras de una oraci√≥n en paralelo. Esto los hace altamente eficientes y precisos en tareas de lenguaje.

#### Componentes Clave
- **Mecanismo de Atenci√≥n**: Pondera la importancia de diferentes palabras en una oraci√≥n.
- **Codificadores y Decodificadores**: Procesan las secuencias de entrada y generan secuencias de salida.

### 5. Modelos de Difusi√≥n üå´Ô∏è

#### Descripci√≥n
Los **Modelos de Difusi√≥n** son una t√©cnica emergente en generaci√≥n de datos. Funcionan modelando la distribuci√≥n de los datos y luego generando nuevos ejemplos a partir de esta distribuci√≥n, similar a los procesos f√≠sicos de difusi√≥n.

#### Componentes Clave
- **Proceso de Difusi√≥n**: Modela c√≥mo los datos cambian con el tiempo.
- **Reconstrucci√≥n Inversa**: Genera nuevos datos a partir del proceso de difusi√≥n.

### 6. Modelos Multimodales üé•üéµüìù

#### Descripci√≥n
Los **Modelos Multimodales** integran y procesan m√∫ltiples tipos de datos, como texto, im√°genes y audio, para realizar tareas complejas que requieren comprensi√≥n de informaci√≥n diversa.

#### Componentes Clave
- **Fusi√≥n de Modalidades**: Combina diferentes tipos de datos en una representaci√≥n unificada.
- **Atenci√≥n Cruzada**: Captura interacciones entre diferentes modalidades.


### Recursos para Explorar M√°s:

- **[¬°Redes Neuronales CONVOLUCIONALES! ](https://youtu.be/V8j1oENVz00?si=RY91rvLjMXPbjRbF)** - Video detallado sobre CNN.
- **[Understanding LSTM Networks](https://colah.github.io/posts/2015-08-Understanding-LSTMs/)** - Una explicaci√≥n profunda sobre las RNN y LSTM.
- **[GANs in Action](https://www.youtube.com/watch?v=8L11aMN5KY8)** - Un video tutorial sobre GANs.
- **[The Illustrated Transformer](https://jalammar.github.io/illustrated-transformer/)** - Una gu√≠a visual sobre transformadores.
- **[C√≥mo funciona la generaci√≥n de im√°genes con IA (modelos de difusi√≥n)](https://youtu.be/mNxzQvdVSQI?si=_Lno74MYiqcbidei)** - Introducci√≥n a los modelos de difusi√≥n.
- **[Multimodal learning](https://en.wikipedia.org/wiki/Multimodal_learning)** - Definicion de Wikipedia.

---

# D√≠a4
---
## Comparaci√≥n y Aplicaciones de T√©cnicas de Deep Learning en el Mundo Real üåç

¬°Hola a todos! compararemos las diferentes t√©cnicas de Deep Learning que discutimos ayer y exploraremos sus aplicaciones en el mundo real. Vamos a sumergirnos en c√≥mo se utilizan las **CNN, RNN, GAN, Transformadores, Modelos de Difusi√≥n y Modelos Multimodales** en diversos campos. üåê

### Comparaci√≥n de T√©cnicas de Deep Learning

| T√©cnica         | Descripci√≥n                                                   | Fortalezas                                                     | Limitaciones                                                       |
|-----------------|---------------------------------------------------------------|----------------------------------------------------------------|--------------------------------------------------------------------|
| **CNN**         | Procesan datos con estructura de grilla (como im√°genes).       | Excelente para tareas de visi√≥n por computadora.                | No maneja bien datos secuenciales o dependencias temporales.       |
| **RNN**         | Procesan secuencias de datos (como texto o series temporales). | Capturan dependencias temporales y contextuales.                | Pueden sufrir de problemas de gradiente desaparecido/explosivo.    |
| **GAN**         | Generan datos sint√©ticos mediante una competencia entre dos redes. | Producen datos realistas en imagen, video y audio.              | Dificultad en entrenamiento y estabilidad.                         |
| **Transformadores** | Procesan secuencias de datos en paralelo utilizando atenci√≥n. | Eficientes y precisos en procesamiento de lenguaje natural.     | Requieren grandes cantidades de datos y recursos computacionales.  |
| **Modelos de Difusi√≥n** | Modelan la distribuci√≥n de datos para generaci√≥n.        | Alta calidad en generaci√≥n de im√°genes y datos.                 | T√©cnicamente complejos y requieren mucho tiempo de entrenamiento.  |
| **Modelos Multimodales** | Integran m√∫ltiples tipos de datos (texto, imagen, audio). | Capturan interacciones complejas entre diferentes tipos de datos. | Complejidad en la fusi√≥n de datos y gesti√≥n de m√∫ltiples modalidades. |

### Aplicaciones en el Mundo Real

#### 1. Redes Neuronales Convolucionales (CNN) üñºÔ∏è

**Aplicaciones:**
- **Reconocimiento de Im√°genes**: Identificaci√≥n de objetos, personas y escenas en im√°genes.
- **Diagn√≥stico M√©dico**: An√°lisis de im√°genes m√©dicas, como radiograf√≠as y resonancias magn√©ticas.
- **Seguridad y Vigilancia**: Detecci√≥n de anomal√≠as y reconocimiento facial.

#### 2. Redes Neuronales Recurrentes (RNN) üîÅ

**Aplicaciones:**
- **Procesamiento del Lenguaje Natural (NLP)**: Traducci√≥n autom√°tica, generaci√≥n de texto, chatbots.
- **An√°lisis de Series Temporales**: Predicci√≥n de mercados financieros, demanda energ√©tica, clima.
- **Reconocimiento de Voz**: Transcripci√≥n y comandos de voz en asistentes virtuales.

#### 3. Redes Generativas Adversariales (GAN) üé®

**Aplicaciones:**
- **Generaci√≥n de Im√°genes y Videos**: Creaci√≥n de arte digital, efectos visuales en pel√≠culas.
- **Aumento de Datos**: Generaci√≥n de datos sint√©ticos para mejorar el entrenamiento de modelos.
- **Restauraci√≥n de Im√°genes**: Mejora de resoluci√≥n, eliminaci√≥n de ruido, restauraci√≥n de im√°genes antiguas.

#### 4. Transformadores üîÑ

**Aplicaciones:**
- **Procesamiento del Lenguaje Natural (NLP)**: Modelos de lenguaje avanzados como GPT, BERT, traducci√≥n autom√°tica.
- **Generaci√≥n de Texto**: Resumen autom√°tico, generaci√≥n de contenido, respuestas autom√°ticas en chats.
- **An√°lisis de Datos**: Clasificaci√≥n de documentos, detecci√≥n de entidades nombradas, an√°lisis de sentimientos.

#### 5. Modelos de Difusi√≥n üå´Ô∏è

**Aplicaciones:**
- **Generaci√≥n de Im√°genes**: Creaci√≥n de im√°genes de alta calidad a partir de descripciones textuales.
- **Simulaci√≥n de Procesos F√≠sicos**: Modelado de fen√≥menos naturales como la difusi√≥n de gases.
- **Dise√±o Gr√°fico**: Creaci√≥n de patrones y texturas para dise√±o digital.

#### 6. Modelos Multimodales üé•üéµüìù

**Aplicaciones:**
- **Sistemas de Recomendaci√≥n**: Recomendaciones personalizadas basadas en m√∫ltiples tipos de datos (texto, im√°genes, audio).
- **An√°lisis de Redes Sociales**: Comprensi√≥n de publicaciones multimedia, an√°lisis de sentimientos.
- **Asistentes Virtuales**: Integraci√≥n de voz, texto e im√°genes para interacci√≥n m√°s natural y completa.


### Recursos para Explorar M√°s:


- **[The GAN Zoo](https://github.com/hindupuravinash/the-gan-zoo)** - Una colecci√≥n de diferentes tipos de GANs.
- **[Attention is All You Need](https://arxiv.org/abs/1706.03762)** - El art√≠culo seminal sobre transformadores.
- **[Explicaci√≥n Completa: Attention is All You Need](https://youtu.be/as2FFM3c6mI?si=_pNuRFCEHHYsizro)** - Un video detallado explicando los transformadores.

---

# D√≠a5
---
## Redes Neuronales Artificiales (ANNs)  üß†

¬°Hola a todos! En el quinto d√≠a de nuestra traves√≠a de 100 d√≠as en el mundo de la Inteligencia Artificial, exploraremos la estructura b√°sica de las Redes Neuronales Artificiales (ANNs) y entenderemos c√≥mo funcionan sus capas neuronales. üåü

### ¬øQu√© son las Redes Neuronales Artificiales (ANNs)?

Las Redes Neuronales Artificiales (ANNs) son modelos computacionales inspirados en el funcionamiento del cerebro humano. Est√°n dise√±adas para reconocer patrones y resolver problemas complejos mediante el aprendizaje a partir de datos. üåê

### Estructura B√°sica de una Red Neuronal

Una red neuronal t√≠pica consta de tres tipos de capas:

1. **Capa de Entrada (Input Layer)**: Recibe los datos iniciales.
2. **Capas Ocultas (Hidden Layers)**: Procesan la informaci√≥n recibida de la capa de entrada.
3. **Capa de Salida (Output Layer)**: Genera el resultado final.


#### 1. **Capa de Entrada (Input Layer)**
La capa de entrada es la primera capa de la red neuronal. Cada nodo en esta capa representa una caracter√≠stica del conjunto de datos de entrada. Por ejemplo, en una red que procesa im√°genes, cada nodo podr√≠a representar el valor de un p√≠xel de la imagen.

#### 2. **Capas Ocultas (Hidden Layers)**
Las capas ocultas son las encargadas de realizar la mayor parte del procesamiento de la red. Pueden existir m√∫ltiples capas ocultas, cada una compuesta por m√∫ltiples nodos o "neuronas". Cada neurona en una capa est√° conectada a todas las neuronas de la capa anterior y de la capa siguiente.

##### Funcionamiento de las Capas Ocultas:
- **Pesos y Sesgos (Weights and Biases)**: Cada conexi√≥n entre neuronas tiene un peso asignado que indica la importancia de la entrada correspondiente. Adem√°s, cada neurona tiene un valor de sesgo que ajusta la salida del nodo.
- **Funciones de Activaci√≥n (Activation Functions)**: Despu√©s de que una neurona recibe la entrada ponderada, aplica una funci√≥n de activaci√≥n para introducir no linealidades en el modelo. Las funciones de activaci√≥n comunes incluyen ReLU (Rectified Linear Unit), Sigmoid y Tanh.



#### 3. **Capa de Salida (Output Layer)**
La capa de salida es la √∫ltima capa de la red neuronal y proporciona el resultado final. La estructura de esta capa depende del tipo de tarea que est√© realizando la red. Por ejemplo, en un problema de clasificaci√≥n binaria, la capa de salida podr√≠a tener una sola neurona con una funci√≥n de activaci√≥n Sigmoid.

### ¬øC√≥mo Aprenden las Redes Neuronales?

El aprendizaje en redes neuronales implica ajustar los pesos y los sesgos de la red para minimizar el error en las predicciones. Este proceso se realiza mediante un algoritmo de optimizaci√≥n llamado **Backpropagation** (retropropagaci√≥n), que utiliza el **Gradiente Descendente** para ajustar los pesos de manera iterativa.


### Recursos para Explorar M√°s:

- **[C√≥mo funcionan las redes neuronales](https://youtu.be/CU24iC3grq8?si=9UT2DpOAA1cQ1Ay0)** (Video).
- **[¬øQu√© es una Red Neuronal?](https://youtu.be/jKCQsndqEGQ?si=jNASfwuoQB9tXyle)** - (Video).
- **[Funciones de activaci√≥n a detalle](https://youtu.be/_0wdproot34?si=B27NeiOze7QGGi6K)** - (Video).
- **[Juegue con una red neuronal ](https://playground.tensorflow.org/#activation=tanh&batchSize=10&dataset=circle&regDataset=reg-plane&learningRate=0.03&regularizationRate=0&noise=0&networkShape=1&seed=0.87931&showTestData=false&discretize=false&percTrainData=50&x=true&y=true&xTimesY=false&xSquared=false&ySquared=false&cosX=false&sinX=false&cosY=false&sinY=false&collectStats=false&problem=classification&initZero=false&hideText=false)** - Juegue con una red neuronal aqu√≠ mismo en su navegador.
No te preocupes, no puedes romperlo.
![ANNs](https://github.com/Oliver369X/100DaysOfAI/assets/110129950/6de8c3e3-ea5a-46e0-8fd0-600e794b422d)

![back2](https://github.com/Oliver369X/100DaysOfAI/assets/110129950/2ebfb67d-7af9-49bd-a509-b1d6babf0148)

---

# D√≠a6
---
## Conceptos de Forward y Backward Propagation üß†üîÑ

¬°Hola a todos! Hoy, en el sexto d√≠a de nuestro viaje de 100 d√≠as en el mundo de la Inteligencia Artificial, exploraremos dos conceptos fundamentales para el entrenamiento de redes neuronales: **Forward Propagation** y **Backward Propagation**. Estos procesos son esenciales para que las redes neuronales aprendan de los datos y mejoren su rendimiento. üöÄ

### ¬øQu√© es Forward Propagation?

**Forward Propagation** es el proceso mediante el cual los datos de entrada se transmiten a trav√©s de la red neuronal para generar una salida. Este flujo de informaci√≥n comienza en la capa de entrada, pasa por las capas ocultas y finalmente llega a la capa de salida.

#### Pasos de Forward Propagation:

1. **Entrada**: Los datos de entrada se presentan a la red neuronal.
2. **Ponderaci√≥n**: Cada neurona en la capa de entrada env√≠a sus datos ponderados a cada neurona de la primera capa oculta.
3. **Activaci√≥n**: Las neuronas de la capa oculta calculan una suma ponderada de sus entradas, aplican una funci√≥n de activaci√≥n y transmiten el resultado a la siguiente capa.
4. **Salida**: Este proceso se repite capa por capa hasta que los datos alcanzan la capa de salida, donde se generan las predicciones finales.

### ¬øQu√© es Backward Propagation?

**Backward Propagation** (o retropropagaci√≥n) es el proceso mediante el cual la red neuronal ajusta sus pesos y sesgos para minimizar el error en sus predicciones. Este ajuste se realiza mediante la propagaci√≥n del error desde la capa de salida hacia atr√°s a trav√©s de las capas ocultas, hasta llegar a la capa de entrada.

#### Pasos de Backward Propagation:

1. **C√°lculo del Error**: Se calcula la diferencia entre la salida real de la red y la salida esperada (etiquetas verdaderas).
2. **Propagaci√≥n del Error**: El error se propaga hacia atr√°s a trav√©s de la red. En cada neurona, se calcula el gradiente del error con respecto a sus pesos y sesgos.
3. **Ajuste de Pesos y Sesgos**: Los pesos y sesgos se actualizan utilizando el gradiente calculado y una tasa de aprendizaje, reduciendo as√≠ el error de la red.

### C√≥mo Funcionan Juntos Forward y Backward Propagation

1. **Forward Propagation**: Los datos de entrada se procesan a trav√©s de la red para generar una predicci√≥n.
2. **C√°lculo del Error**: Se compara la predicci√≥n con la etiqueta verdadera para calcular el error.
3. **Backward Propagation**: El error se propaga hacia atr√°s a trav√©s de la red, y los pesos y sesgos se ajustan en consecuencia.
4. **Actualizaci√≥n de Par√°metros**: Los par√°metros de la red se actualizan para reducir el error en futuras predicciones.

### Ejemplo Simplificado

Imaginemos que estamos entrenando una red neuronal para predecir el precio de una casa basado en su tama√±o.

1. **Forward Propagation**:
   - Entrada: Tama√±o de la casa.
   - C√°lculo: La red multiplica el tama√±o por un peso, a√±ade un sesgo y aplica una funci√≥n de activaci√≥n.
   - Salida: Predicci√≥n del precio de la casa.

2. **C√°lculo del Error**:
   - Comparamos la predicci√≥n con el precio real y calculamos el error.

3. **Backward Propagation**:
   - Propagamos el error hacia atr√°s a trav√©s de la red, calculando el gradiente del error con respecto a cada peso y sesgo.
   - Ajustamos los pesos y sesgos para minimizar el error en futuras predicciones.


### Recursos para Explorar M√°s:

- **[Redes Neuronales (forward propagation y backpropagation)](https://youtu.be/A9jZflhT2R0?si=uQj8Xw1xa2_O1kDO)** -Explicacion matematica(Video).
- **[Las Matem√°ticas de Backpropagation | DotCSV](https://youtu.be/M5QHwkkHgAA?si=ZiX3Gp9I25liaNFq)** - Explicacion matematica(Video).

---

# D√≠a7

---
## Conceptos de Coste y Funciones de P√©rdida üí°üìâ

¬°Hola a todos! Hoy, en el s√©ptimo d√≠a de nuestro reto #100DaysOfAI, exploraremos dos conceptos fundamentales para el entrenamiento de redes neuronales: **coste** y **funciones de p√©rdida**. Estos conceptos son esenciales para evaluar el rendimiento de nuestros modelos y guiar el proceso de aprendizaje. üöÄ

### ¬øQu√© es el Coste?

El **coste** se refiere a la medida de lo mal que un modelo de red neuronal est√° realizando sus predicciones en comparaci√≥n con los valores reales. En otras palabras, es una representaci√≥n cuantitativa del error del modelo. Cuanto menor sea el coste, mejor ser√° el rendimiento del modelo.

### ¬øQu√© es una Funci√≥n de P√©rdida?

Una **funci√≥n de p√©rdida** es una funci√≥n matem√°tica que mide la discrepancia entre las predicciones del modelo y los valores reales. Durante el entrenamiento, el objetivo es minimizar esta funci√≥n de p√©rdida para mejorar la precisi√≥n del modelo. 

### Tipos Comunes de Funciones de P√©rdida:

1. **Error Cuadr√°tico Medio (Mean Squared Error, MSE)**:

2. **Error Absoluto Medio (Mean Absolute Error, MAE)**:


3. **Entrop√≠a Cruzada (Cross-Entropy)**:


### Relaci√≥n entre Coste y Funci√≥n de P√©rdida:

- **Coste Total**: La funci√≥n de p√©rdida calcula el error para una sola instancia de datos, mientras que el coste total (tambi√©n conocido como funci√≥n de coste o funci√≥n de error) es la media de las p√©rdidas para todo el conjunto de entrenamiento.
- **Optimizaci√≥n**: Durante el entrenamiento, el algoritmo de optimizaci√≥n ajusta los pesos de la red neuronal para minimizar el coste total. Esto se realiza t√≠picamente mediante un algoritmo de optimizaci√≥n como el gradiente descendente.

### Importancia en el Entrenamiento

1. **Evaluaci√≥n del Modelo**: Las funciones de p√©rdida nos permiten evaluar cu√°n bien o mal est√° desempe√±√°ndose el modelo.
2. **Gu√≠a para la Optimizaci√≥n**: Proveen la se√±al que gu√≠a el proceso de optimizaci√≥n durante el entrenamiento. Sin una funci√≥n de p√©rdida, no podr√≠amos ajustar los pesos de manera efectiva.
3. **Selecci√≥n de Modelos**: Diferentes problemas pueden requerir diferentes funciones de p√©rdida. Elegir la funci√≥n correcta es crucial para el √©xito del modelo.


### Recursos para Explorar M√°s:

- **[3Blue1Brown's YouTube Series on Neural Networks](https://youtu.be/mwHiaTrQOiI?si=j_a-9WxP_1um9YVc)** - Una serie de videos educativos que visualizan estos procesos de manera intuitiva.

---

# D√≠a8

---
## Algoritmos de Optimizaci√≥n  üöÄüìà

¬°Hola a todos! En el d√≠a 8 de nuestro reto #100DaysOfAI, vamos a profundizar en los **algoritmos de optimizaci√≥n avanzados**. Estos algoritmos son esenciales para mejorar el rendimiento y la eficiencia de los modelos de aprendizaje profundo. ¬°Vamos a explorarlos juntos! üåü

### ¬øQu√© es la Optimizaci√≥n?

La **optimizaci√≥n** en el contexto del aprendizaje profundo se refiere al proceso de ajustar los par√°metros del modelo (como los pesos de las redes neuronales) para minimizar la funci√≥n de p√©rdida. Este proceso es crucial para que el modelo pueda aprender de los datos y hacer predicciones precisas.

### Algoritmos de Optimizaci√≥n Comunes

1. **Gradiente Descendente Estoc√°stico (SGD)**:
   - **Descripci√≥n**: En lugar de utilizar todo el conjunto de datos para calcular los gradientes, el SGD actualiza los par√°metros del modelo usando un solo ejemplo de entrenamiento a la vez.
   - **Ventaja**: Es m√°s r√°pido y puede manejar grandes conjuntos de datos.

2. **Gradiente Descendente por Minilotes (Mini-batch Gradient Descent)**:
   - **Descripci√≥n**: Combina los enfoques de SGD y del gradiente descendente de lote completo, actualizando los par√°metros utilizando un peque√±o subconjunto (mini-lote) de los datos de entrenamiento.
   - **Ventaja**: Equilibra la estabilidad del gradiente descendente de lote completo y la rapidez del SGD.

### Algoritmos de Optimizaci√≥n Avanzados

1. **Momentum**:
   - **Descripci√≥n**: Agrega una fracci√≥n del gradiente anterior al gradiente actual para acelerar la convergencia y evitar quedarse atrapado en m√≠nimos locales.
   - **Ventaja**: Mejora la velocidad y estabilidad del SGD.
  

2. **RMSprop**:
   - **Descripci√≥n**: Divide la tasa de aprendizaje por una media m√≥vil de la magnitud de los gradientes recientes. Esto ayuda a mantener una tasa de aprendizaje adecuada y evita oscilaciones.
   - **Ventaja**: Mantiene una tasa de aprendizaje adaptativa.
  

3. **Adam (Adaptive Moment Estimation)**:
   - **Descripci√≥n**: Combina las ideas de Momentum y RMSprop. Utiliza medias m√≥viles de los gradientes y sus cuadrados, adaptando as√≠ la tasa de aprendizaje para cada par√°metro.
   - **Ventaja**: Convergencia r√°pida y robusta.
  

4. **AdaGrad**:
   - **Descripci√≥n**: Ajusta la tasa de aprendizaje para cada par√°metro en funci√≥n de los gradientes acumulados pasados. 
   - **Ventaja**: Beneficioso para caracter√≠sticas raras y evita el ajuste excesivo en caracter√≠sticas comunes.
   
### Comparaci√≥n de Algoritmos

- **SGD**: Simple y eficiente para grandes conjuntos de datos, pero puede ser ruidoso.
- **Momentum**: Acelera el SGD y suaviza la convergencia.
- **RMSprop**: Adapta la tasa de aprendizaje, √∫til para problemas con tasas de aprendizaje inestables.
- **Adam**: Combina las ventajas de Momentum y RMSprop, ampliamente utilizado.
- **AdaGrad**: Ajusta la tasa de aprendizaje para cada par√°metro, √∫til para datos dispersos.


### Recursos para Explorar M√°s:

- **[Adam - A Method for Stochastic Optimization](https://arxiv.org/abs/1412.6980)** - El art√≠culo original que introduce Adam.
- **[Algoritmos de Optimizaci√≥n ](https://youtu.be/1GFu3nOya4c?si=v3jnhocKnb_R0Xw_)** - Explicacion completa (Video).


---

# D√≠a9
---
## Overfitting y T√©cnicas de Regularizaci√≥n üß†üîç

¬°Hola a todos! En el d√≠a 9 de nuestro desaf√≠o #100DaysOfAI, vamos a sumergirnos en el concepto de **overfitting** y las t√©cnicas de **regularizaci√≥n**. Estas son herramientas fundamentales para mejorar la capacidad predictiva y la generalizaci√≥n de nuestros modelos de aprendizaje profundo. ¬°Vamos a explorarlas juntos! üìâüìö

### ¬øQu√© es el Overfitting?

El **overfitting** ocurre cuando nuestro modelo se ajusta demasiado bien a los datos de entrenamiento, capturando no solo la se√±al real sino tambi√©n el ruido. Como resultado, el modelo puede tener un rendimiento deficiente en datos nuevos y no vistos, lo que lleva a una baja capacidad de generalizaci√≥n.

### T√©cnicas de Regularizaci√≥n

1. **Regularizaci√≥n L1 y L2**:
   - **Descripci√≥n**: Agrega un t√©rmino de penalizaci√≥n a la funci√≥n de p√©rdida que es proporcional a la norma L1 o L2 de los pesos del modelo.
   - **Ventaja**: Ayuda a prevenir el overfitting al penalizar los pesos grandes.

2. **Dropout**:
   - **Descripci√≥n**: Aleatoriamente "apaga" una fracci√≥n de las neuronas durante el entrenamiento, lo que obliga al modelo a aprender caracter√≠sticas m√°s robustas y reduce la dependencia entre las neuronas.
   - **Ventaja**: Act√∫a como una forma de regularizaci√≥n al evitar la coadaptaci√≥n de las neuronas.

3. **Data Augmentation**:
   - **Descripci√≥n**: Aumenta el tama√±o del conjunto de datos de entrenamiento aplicando transformaciones como rotaciones, traslaciones y zoom a las im√°genes originales.
   - **Ventaja**: Ayuda a diversificar el conjunto de datos de entrenamiento y a mejorar la generalizaci√≥n del modelo.

4. **Early Stopping**:
   - **Descripci√≥n**: Detiene el entrenamiento del modelo cuando el rendimiento en un conjunto de datos de validaci√≥n deja de mejorar.
   - **Ventaja**: Evita el sobreajuste al detener el entrenamiento antes de que el modelo comience a sobreajustarse a los datos de entrenamiento.

### Aplicaci√≥n en la Pr√°ctica

Para aplicar estas t√©cnicas de regularizaci√≥n en nuestros modelos, debemos ajustar los hiperpar√°metros adecuados y experimentar con diferentes configuraciones para encontrar el equilibrio √≥ptimo entre la capacidad de ajuste y la generalizaci√≥n.

### Recursos para Explorar M√°s:

- **[Overfitting ](https://youtube.com/playlist?list=PLWP2CHQigyUSw1TJkOdAxzBC0BtKrYAnz&si=InFqmXxk1iRgX611)** - Playlists de underfitting y overfitting.
- **[Dropout: A Simple Way to Prevent Neural Networks from Overfitting](https://www.cs.toronto.edu/~hinton/absps/JMLRdropout.pdf)** - El art√≠culo seminal que introduce la t√©cnica de dropout.
- **[T√©cnicas de Regularizaci√≥n](https://youtu.be/qa9M4NBV9Lk?si=G09xw9uQaTsmwmY4)** - Explicaion practica.


---

# D√≠a10
---
## Construyendo una Red Neuronal desde Cero: Clasificaci√≥n de Flores Iris
### Introducci√≥n al Problema y Objetivos

En esta pr√°ctica, vamos a implementar una red neuronal simple desde cero para resolver el problema de clasificaci√≥n de flores Iris. Este es un problema cl√°sico en el aprendizaje autom√°tico y es perfecto para entender los fundamentos de las redes neuronales.

**Objetivo:** Crear una red neuronal que pueda clasificar correctamente las flores Iris en sus tres especies (setosa, versicolor, virginica) bas√°ndose en cuatro caracter√≠sticas: longitud del s√©palo, ancho del s√©palo, longitud del p√©talo y ancho del p√©talo.

**¬øPor qu√© usar redes neuronales?** Las redes neuronales son excelentes para encontrar patrones complejos en los datos. En este caso, pueden aprender las relaciones no lineales entre las caracter√≠sticas de las flores y sus especies, permitiendo una clasificaci√≥n precisa.
![iris_flowers](https://github.com/Oliver369X/100DaysOfAI/assets/110129950/c98d7fec-a4ad-478e-ba49-bdc24b63e98e)

---

## Importaci√≥n de Librer√≠as

Primero, importaremos las librer√≠as necesarias para nuestro proyecto.

```python
import numpy as np
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder
import matplotlib.pyplot as plt
```

Explicaci√≥n:
- `numpy`: Para operaciones num√©ricas eficientes.
- `sklearn.datasets`: Para cargar el conjunto de datos Iris.
- `sklearn.model_selection`: Para dividir nuestros datos en conjuntos de entrenamiento y prueba.
- `sklearn.preprocessing`: Para codificar nuestras etiquetas.
- `matplotlib.pyplot`: Para visualizar nuestros resultados.

---

## Carga y Preparaci√≥n del Conjunto de Datos

El conjunto de datos Iris es un conjunto cl√°sico en aprendizaje autom√°tico. Contiene 150 muestras de flores Iris, con 50 muestras de cada una de las tres especies.

```python
# Cargar el conjunto de datos Iris
iris = load_iris()
X = iris.data
y = iris.target.reshape(-1, 1)

# One-hot encoding para las etiquetas
encoder = OneHotEncoder(sparse=False)
y = encoder.fit_transform(y)

# Dividir datos en entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("Forma de X_train:", X_train.shape)
print("Forma de y_train:", y_train.shape)
print("Forma de X_test:", X_test.shape)
print("Forma de y_test:", y_test.shape)
```

Explicaci√≥n:
- Cargamos el conjunto de datos Iris.
- Aplicamos one-hot encoding a las etiquetas para convertirlas en un formato adecuado para la red neuronal.
- Dividimos los datos en conjuntos de entrenamiento (80%) y prueba (20%).
- Imprimimos las formas de nuestros conjuntos de datos para verificar.

---

## Implementaci√≥n de la Red Neuronal

Ahora, implementaremos nuestra clase de red neuronal simple.

```python
class SimpleNeuralNetwork:
    def __init__(self, input_size, hidden_size, output_size):
        self.W1 = np.random.randn(input_size, hidden_size) * 0.01
        self.b1 = np.zeros((1, hidden_size))
        self.W2 = np.random.randn(hidden_size, output_size) * 0.01
        self.b2 = np.zeros((1, output_size))

    def sigmoid(self, x):
        return 1 / (1 + np.exp(-x))

    def softmax(self, x):
        exp_x = np.exp(x - np.max(x, axis=1, keepdims=True))
        return exp_x / np.sum(exp_x, axis=1, keepdims=True)
```

Explicaci√≥n:
- Inicializamos los pesos (`W1`, `W2`) y sesgos (`b1`, `b2`) de nuestra red.
- Implementamos la funci√≥n de activaci√≥n sigmoid para la capa oculta.
- Implementamos la funci√≥n softmax para la capa de salida, que nos dar√° probabilidades para cada clase.

---

## Forward Propagation

Implementamos el paso hacia adelante (forward propagation) de nuestra red.

```python
def forward(self, X):
    self.z1 = np.dot(X, self.W1) + self.b1
    self.a1 = self.sigmoid(self.z1)
    self.z2 = np.dot(self.a1, self.W2) + self.b2
    self.a2 = self.softmax(self.z2)
    return self.a2
```

Explicaci√≥n:
- Calculamos la salida de la capa oculta (`z1`) y aplicamos la funci√≥n sigmoid (`a1`).
- Calculamos la salida de la capa final (`z2`) y aplicamos softmax (`a2`).
- Retornamos la salida final, que son las probabilidades para cada clase.

---

## Funci√≥n de P√©rdida

Implementamos la funci√≥n de p√©rdida de entrop√≠a cruzada.

```python
def cross_entropy_loss(self, y_true, y_pred):
    m = y_true.shape[0]
    log_likelihood = -np.log(y_pred[range(m), y_true.argmax(axis=1)])
    loss = np.sum(log_likelihood) / m
    return loss
```

Explicaci√≥n:
- Calculamos la p√©rdida de entrop√≠a cruzada entre las etiquetas verdaderas y las predicciones.
- Esta funci√≥n mide qu√© tan bien nuestras predicciones se ajustan a las etiquetas reales.

---

## Backward Propagation

Implementamos la retropropagaci√≥n (backward propagation) para actualizar los pesos.

```python
def backward(self, X, y, learning_rate):
    m = X.shape[0]
    
    dZ2 = self.a2 - y
    dW2 = np.dot(self.a1.T, dZ2) / m
    db2 = np.sum(dZ2, axis=0, keepdims=True) / m
    
    dZ1 = np.dot(dZ2, self.W2.T) * (self.a1 * (1 - self.a1))
    dW1 = np.dot(X.T, dZ1) / m
    db1 = np.sum(dZ1, axis=0, keepdims=True) / m
    
    self.W2 -= learning_rate * dW2
    self.b2 -= learning_rate * db2
    self.W1 -= learning_rate * dW1
    self.b1 -= learning_rate * db1
```

Explicaci√≥n:
- Calculamos los gradientes para cada capa.
- Actualizamos los pesos y sesgos usando estos gradientes y la tasa de aprendizaje.

---

## Entrenamiento

Implementamos el bucle de entrenamiento.

```python
def train(self, X, y, epochs, learning_rate, batch_size):
    losses = []
    for epoch in range(epochs):
        for i in range(0, X.shape[0], batch_size):
            X_batch = X[i:i+batch_size]
            y_batch = y[i:i+batch_size]
            
            y_pred = self.forward(X_batch)
            loss = self.cross_entropy_loss(y_batch, y_pred)
            self.backward(X_batch, y_batch, learning_rate)
            
        if epoch % 100 == 0:
            losses.append(loss)
            print(f"Epoch {epoch}, Loss: {loss}")
    return losses
```

Explicaci√≥n:
- Entrenamos la red durante un n√∫mero especificado de √©pocas.
- Usamos mini-batch gradient descent para actualizar los pesos.
- Registramos la p√©rdida cada 100 √©pocas para monitorear el progreso.

---

## Evaluaci√≥n

Implementamos funciones para hacer predicciones y calcular la precisi√≥n.

```python
def predict(self, X):
    return np.argmax(self.forward(X), axis=1)

def accuracy(self, X, y):
    predictions = self.predict(X)
    return np.mean(predictions == np.argmax(y, axis=1))
```

Explicaci√≥n:
- `predict`: Hace predicciones para nuevos datos.
- `accuracy`: Calcula la precisi√≥n de nuestras predicciones.

---

## Entrenamiento y Evaluaci√≥n del Modelo

Ahora, entrenamos nuestro modelo y evaluamos su rendimiento.

```python
# Crear y entrenar el modelo
model = SimpleNeuralNetwork(input_size=4, hidden_size=10, output_size=3)
losses = model.train(X_train, y_train, epochs=1000, learning_rate=0.1, batch_size=32)

# Evaluar el modelo
train_accuracy = model.accuracy(X_train, y_train)
test_accuracy = model.accuracy(X_test, y_test)

print(f"Precisi√≥n en entrenamiento: {train_accuracy:.4f}")
print(f"Precisi√≥n en prueba: {test_accuracy:.4f}")
```

Explicaci√≥n:
- Creamos una instancia de nuestra red neuronal.
- Entrenamos el modelo durante 1000 √©pocas.
- Evaluamos la precisi√≥n en los conjuntos de entrenamiento y prueba.

---

## Visualizaci√≥n de Resultados

Finalmente, visualizamos c√≥mo la p√©rdida cambia durante el entrenamiento.

```python
plt.plot(range(0, 1000, 100), losses)
plt.xlabel('√âpocas')
plt.ylabel('P√©rdida')
plt.title('P√©rdida durante el entrenamiento')
plt.show()
```

Explicaci√≥n:
- Graficamos la p√©rdida a lo largo de las √©pocas de entrenamiento.
- Esto nos ayuda a visualizar c√≥mo el modelo aprende con el tiempo.


### Recursos para Explorar M√°s:

- **[An√°lisis exploratorio de datos del conjunto de datos Iris](https://youtu.be/yu4SYEYkZ6U?si=oOb1DEuG5GcS-f4e)** MasterClass (video)
- **[Analisis Exploratorio de Datos dataset Iris](https://www.kaggle.com/code/joeportilla/analisis-exploratorio-de-datos-dataset-iris)** - Notebook Kaggle.

## Colab Notebooks

- [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1Qv7LRrhvzGuJPkelYWz9zYJz-oPYIqDJ?usp=sharing) [D√≠a 10: Clasificaci√≥n de Flores Iris](https://colab.research.google.com/drive/1Qv7LRrhvzGuJPkelYWz9zYJz-oPYIqDJ?usp=sharing) 


---

# D√≠a11
---

## Redes Neuronales Artificiales (ANNs) con MNIST

### Introducci√≥n

En este proyecto, exploraremos la estructura b√°sica de las Redes Neuronales Artificiales (ANNs) y su funcionamiento implementando un modelo para clasificar d√≠gitos escritos a mano utilizando el dataset MNIST.

Las ANNs son modelos computacionales inspirados en el cerebro humano. Est√°n dise√±adas para reconocer patrones y resolver problemas complejos a partir de datos. Una ANN t√≠pica consta de tres tipos de capas:
- **Capa de Entrada**: Recibe los datos iniciales.
- **Capas Ocultas**: Procesan la informaci√≥n.
- **Capa de Salida**: Genera el resultado final.

Nuestro objetivo es construir, entrenar y evaluar una ANN usando el dataset MNIST para clasificar im√°genes de d√≠gitos escritos a mano.
![Clasificaci√≥n de Numeros Escritos a Mano](https://github.com/Oliver369X/100DaysOfAI/assets/110129950/4ca7e2c8-2f28-423c-b13b-2fcca5647892)

### Importaci√≥n de Bibliotecas y Dataset

En este punto, importaremos las bibliotecas necesarias y cargaremos el dataset MNIST. Tambi√©n explicaremos el dataset y proporcionaremos el enlace original.

#### Explicaci√≥n del C√≥digo y Dataset

```python
# Importaci√≥n de Bibliotecas
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Flatten
from tensorflow.keras.datasets import mnist
from tensorflow.keras.utils import to_categorical
import matplotlib.pyplot as plt
import numpy as np

# Cargando y Preprocesando el Dataset MNIST
(x_train, y_train), (x_test, y_test) = mnist.load_data()

# Normalizaci√≥n de las Im√°genes
x_train = x_train.reshape(-1, 28*28).astype('float32') / 255
x_test = x_test.reshape(-1, 28*28).astype('float32') / 255

# Conversi√≥n de Etiquetas a Categ√≥ricas
y_train = to_categorical(y_train, 10)
y_test = to_categorical(y_test, 10)

# Visualizaci√≥n de ejemplos de im√°genes y sus etiquetas
plt.figure(figsize=(10, 5))
for i in range(10):
    plt.subplot(2, 5, i+1)
    plt.imshow(x_train[i].reshape(28, 28), cmap='gray')
    plt.title(f"Etiqueta: {np.argmax(y_train[i])}")
    plt.axis('off')
plt.show()
```

### Explicaci√≥n del Dataset MNIST

El dataset MNIST (Modified National Institute of Standards and Technology) es una colecci√≥n de im√°genes de d√≠gitos escritos a mano, ampliamente utilizado para entrenar y probar modelos de reconocimiento de im√°genes. El dataset contiene:
- **60,000 im√°genes de entrenamiento**: utilizadas para entrenar el modelo.
- **10,000 im√°genes de prueba**: utilizadas para evaluar el rendimiento del modelo.

Cada imagen tiene un tama√±o de 28x28 p√≠xeles y est√° en escala de grises. Las etiquetas corresponden a d√≠gitos del 0 al 9.

Enlace original al dataset MNIST: [MNIST Database](http://yann.lecun.com/exdb/mnist/)

### Definiendo la Estructura de la Red Neuronal

Ahora definiremos la estructura b√°sica de nuestra red neuronal usando Keras, una biblioteca de alto nivel para redes neuronales.

```python
# Definici√≥n de la Estructura de la Red Neuronal
model = Sequential([
    Dense(512, input_shape=(784,), activation='relu'), # Primera capa oculta con 512 neuronas y ReLU
    Dropout(0.2), # Dropout con el 20% de las neuronas apagadas durante el entrenamiento
    Dense(512, activation='relu'), # Segunda capa oculta con 512 neuronas y ReLU
    Dropout(0.2), # Dropout con el 20% de las neuronas apagadas durante el entrenamiento
    Dense(10, activation='softmax') # Capa de salida con 10 neuronas (una por clase) y Softmax
])

# Compilando el Modelo
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Resumen de la Red Neuronal
model.summary()
```

### Explicaci√≥n de la Estructura de la Red Neuronal

- **Primera Capa Oculta**: Tiene 512 neuronas y utiliza la funci√≥n de activaci√≥n ReLU (Rectified Linear Unit) para introducir no linealidades en el modelo.
- **Dropout**: Aplica Dropout con una tasa del 20% para evitar el sobreajuste.
- **Segunda Capa Oculta**: Similar a la primera, con 512 neuronas y ReLU.
- **Dropout**: Otro Dropout con una tasa del 20%.
- **Capa de Salida**: Tiene 10 neuronas, una para cada clase en el dataset MNIST, y utiliza la funci√≥n de activaci√≥n Softmax para producir probabilidades de clasificaci√≥n.

La red se compila utilizando la p√©rdida de entrop√≠a cruzada categ√≥rica y el optimizador Adam, y se eval√∫a la precisi√≥n durante el entrenamiento.

### Entrenamiento del Modelo

#### Propagaci√≥n Hacia Adelante

La Propagaci√≥n Hacia Adelante es el proceso mediante el cual los datos de entrada se transmiten a trav√©s de la red neuronal para generar una salida. Este flujo de informaci√≥n comienza en la capa de entrada, pasa por las capas ocultas y finalmente llega a la capa de salida.

### Explicaci√≥n del Proceso

1. **Entrada**: Los datos de entrada se presentan a la red neuronal.
2. **Ponderaci√≥n**: Cada neurona en la capa de entrada env√≠a sus datos ponderados a cada neurona en la primera capa oculta.
3. **Activaci√≥n**: Las neuronas en la capa oculta calculan una suma ponderada de sus entradas, aplican una funci√≥n de activaci√≥n y transmiten el resultado a la siguiente capa.
4. **Salida**: Este proceso se repite capa por capa hasta que los datos llegan a la capa de salida, donde se generan las predicciones finales.

```python
# Propagaci√≥n Hacia Adelante usando Keras
# Ya hemos definido y compilado el modelo en el paso anterior
# Entrenamiento del Modelo
history = model.fit(x_train, y_train, epochs=10, batch_size=128, validation_split=0.2, verbose=1)
```

### Visualizaci√≥n del Proceso

Podemos visualizar c√≥mo se transmiten los datos a trav√©s de la red utilizando gr√°ficos de entrenamiento.

```python
# Graficando precisi√≥n y p√©rdida durante el entrenamiento
plt.figure(figsize=(12, 4))
# Precisi√≥n
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Precisi√≥n de Entrenamiento')
plt.plot(history.history['val_accuracy'], label='Precisi√≥n de Validaci√≥n')
plt.title('Precisi√≥n durante el Entrenamiento')
plt.xlabel('√âpoca')
plt.ylabel('Precisi√≥n')
plt.legend()
# P√©rdida
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='P√©rdida de Entrenamiento')
plt.plot(history.history['val_loss'], label='P√©rdida de Validaci√≥n')
plt.title('P√©rdida durante el Entrenamiento')
plt.xlabel('√âpoca')
plt.ylabel('P√©rdida')
plt.legend()
plt.show()
```

### Evaluaci√≥n del Modelo

Evaluaremos el rendimiento del modelo en el conjunto de datos de prueba y mostraremos ejemplos de predicciones.

```python
# La retropropagaci√≥n y el ajuste de pesos se realizan autom√°ticamente durante el entrenamiento
# utilizando el m√©todo fit como se mostr√≥ anteriormente
# Aqu√≠ mostramos la evaluaci√≥n del modelo
loss, accuracy = model.evaluate(x_test, y_test, verbose=0)
print(f'P√©rdida en el conjunto de prueba: {loss:.4f}')
print(f'Precisi√≥n en el conjunto de prueba: {accuracy:.4f}')

import numpy as np
# Haciendo predicciones
predictions = model.predict(x_test)

# Mostrando ejemplos de predicciones
num_rows, num_cols = 2, 5
num_images = num_rows * num_cols
plt.figure(figsize=(10, 5))
for i in range(num_images):
    plt.subplot(num_rows, num_cols, i+1)
    plt.imshow(x_test[i].reshape(28, 28), cmap='gray')
    plt.title(f"Pred: {np.argmax(predictions[i])}")
    plt.axis('off')
plt.show()
```

### T√©cnicas de Regularizaci√≥n

Implementaremos y explicaremos t√©cnicas como Dropout y regularizaci√≥n L2, y mostraremos c√≥mo estas t√©cnicas afectan el rendimiento del modelo.

```python
from keras.layers import Dropout
# Redefiniendo el modelo con Dropout y Regularizaci√≥n L2
from keras.regularizers import l2

model = Sequential([
    Dense(512, activation='relu', input_shape=(784,), kernel_regularizer=l2(0.001)),
    Dropout(0.5),
    Dense(512, activation='relu', kernel_regularizer=l2(0.001)),
    Dropout(0.5),
    Dense(10, activation='softmax')
])
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

# Entrenando el modelo con regularizaci√≥n
history = model.fit(x_train, y_train, epochs=10, batch_size=128, validation_split=0.2, verbose=1)

# Graficando precisi√≥n y p√©rdida durante el entrenamiento con regularizaci√≥n
plt.figure(figsize=(12, 4))
#

 Precisi√≥n
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Precisi√≥n de Entrenamiento')
plt.plot(history.history['val_accuracy'], label='Precisi√≥n de Validaci√≥n')
plt.title('Precisi√≥n durante el Entrenamiento con Regularizaci√≥n')
plt.xlabel('√âpoca')
plt.ylabel('Precisi√≥n')
plt.legend()
# P√©rdida
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='P√©rdida de Entrenamiento')
plt.plot(history.history['val_loss'], label='P√©rdida de Validaci√≥n')
plt.title('P√©rdida durante el Entrenamiento con Regularizaci√≥n')
plt.xlabel('√âpoca')
plt.ylabel('P√©rdida')
plt.legend()
plt.show()
```

### Recursos para Explorar M√°s:

- **[Hola Mundo del Deep Learning](https://youtube.com/playlist?list=PLWP2CHQigyURotrsA7m39odxXuYAOMvEc&si=nJKJn4Xm1szrwGEZ)** PlayList de 0 a 100 para poder hacer y enteder el hola mundo del Deep Learning
- **[Taller - Fundamentos de Deep Learning con Python y PyTorch](https://youtu.be/XtLpw3SFrz4?si=YeQQu8yB_zmoxcf4)** 

## Colab Notebooks


- [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1jokMDImAKHwhucMxo6ZW1Cs2OXlHUpyR?usp=sharing) [D√≠a 11: Hola Mundo (Deep Learning)](https://colab.research.google.com/drive/1jokMDImAKHwhucMxo6ZW1Cs2OXlHUpyR?usp=sharing)

---
# D√≠a12
---
## ¬øQu√© son las Redes Profundas? üåêüß†


Las **redes profundas**, tambi√©n conocidas como **redes neuronales profundas**, son un tipo de arquitectura de aprendizaje profundo que consta de m√∫ltiples capas de neuronas artificiales. A diferencia de las redes neuronales poco profundas, que tienen solo una o dos capas ocultas, las redes profundas pueden tener muchas capas ocultas, lo que les permite aprender representaciones cada vez m√°s abstractas y complejas de los datos de entrada.


https://github.com/Oliver369X/100DaysOfAI/assets/110129950/10319956-2748-4d00-885a-f9f590ead99f


### Caracter√≠sticas Principales:

1. **Capas Ocultas M√∫ltiples**: Las redes profundas consisten en una serie de capas ocultas entre la capa de entrada y la capa de salida. Cada capa oculta realiza transformaciones no lineales en los datos de entrada, permitiendo que el modelo aprenda caracter√≠sticas jer√°rquicas.

2. **Aprendizaje Jer√°rquico de Caracter√≠sticas**: A medida que los datos fluyen a trav√©s de las capas de la red, se extraen y aprenden caracter√≠sticas cada vez m√°s abstractas y significativas. Esto permite a las redes profundas capturar y modelar relaciones complejas en los datos.

3. **Representaciones de Datos Abstracciones**: Las capas intermedias de una red profunda act√∫an como extractores de caracter√≠sticas, aprendiendo representaciones de datos cada vez m√°s abstractas y de alto nivel. Estas representaciones abstra√≠das son esenciales para la capacidad del modelo de comprender y generalizar a partir de datos no vistos.

### Aplicaciones:

- **Visi√≥n por Computadora**: Las redes profundas han demostrado un rendimiento sobresaliente en tareas como clasificaci√≥n de im√°genes, detecci√≥n de objetos, segmentaci√≥n sem√°ntica y generaci√≥n de im√°genes.

- **Procesamiento del Lenguaje Natural**: En el campo del procesamiento del lenguaje natural (NLP), las redes profundas se utilizan para tareas como clasificaci√≥n de texto, traducci√≥n autom√°tica, generaci√≥n de texto y an√°lisis de sentimientos.

- **Reconocimiento de Voz**: Las redes profundas son fundamentales en sistemas de reconocimiento de voz, donde se utilizan para traducir se√±ales de audio en texto y viceversa.



## Ventajas y Desaf√≠os de Redes M√°s Profundas üåüüß†

Vamos a explorar las ventajas y desaf√≠os asociados con el uso de **redes m√°s profundas** en el aprendizaje profundo. Estas redes neuronales, con m√∫ltiples capas ocultas, han demostrado ser poderosas en la extracci√≥n de caracter√≠sticas complejas de los datos, pero tambi√©n presentan ciertos desaf√≠os que debemos tener en cuenta. ¬°Vamos a sumergirnos en este tema! üöÄüìä

### Ventajas de las Redes M√°s Profundas:

1. **Extracci√≥n Jer√°rquica de Caracter√≠sticas**: Las redes profundas pueden aprender representaciones de datos jer√°rquicas y complejas, lo que les permite capturar caracter√≠sticas abstractas y significativas de los datos de entrada.

2. **Mayor Capacidad de Aprendizaje**: Con m√°s capas ocultas, las redes profundas tienen una mayor capacidad para aprender y modelar relaciones complejas en los datos, lo que puede llevar a un rendimiento mejorado en tareas de aprendizaje autom√°tico.

3. **Generalizaci√≥n Mejorada**: Al aprender representaciones de datos m√°s abstractas y de alto nivel, las redes profundas tienden a generalizar mejor a datos no vistos, lo que les permite realizar predicciones precisas en nuevas instancias.

4. **Rendimiento Superior en Tareas Complejas**: Las redes m√°s profundas han demostrado un rendimiento sobresaliente en una variedad de tareas complejas, como la visi√≥n por computadora, el procesamiento del lenguaje natural y el reconocimiento de voz.

### Desaf√≠os de las Redes M√°s Profundas:

1. **Dificultad de Entrenamiento**: Entrenar redes profundas puede ser computacionalmente costoso y requiere grandes conjuntos de datos etiquetados, as√≠ como una capacidad de c√≥mputo significativa, lo que puede ser un desaf√≠o en entornos con recursos limitados.

2. **Sobreajuste (Overfitting)**: Las redes profundas pueden ser propensas al sobreajuste, especialmente en conjuntos de datos peque√±os o ruidosos, lo que puede resultar en un rendimiento deficiente en datos no vistos.

3. **Gradiente que Desaparece/Explode**: En redes muy profundas, el gradiente puede desvanecerse (cuando se vuelve muy peque√±o) o explotar (cuando se vuelve muy grande) durante el entrenamiento, lo que puede dificultar la convergencia del modelo.

4. **Interpretabilidad Limitada**: A medida que aumenta la complejidad de la red, la interpretaci√≥n de sus decisiones puede volverse m√°s dif√≠cil, lo que puede ser problem√°tico en aplicaciones donde la transparencia y la explicabilidad son importantes.

### Recursos para Explorar M√°s:

- **[¬øCu√°les son los desaf√≠os y limitaciones actuales de las redes neuronales y el aprendizaje profundo?](https://www.linkedin.com/advice/3/what-current-challenges-limitations-neural?lang=es&originalSubdomain=es)**.





---

# D√≠a13
---
## Conceptos b√°sicos y arquitectura general de las CNNs üß†üñºÔ∏è


https://github.com/Oliver369X/100DaysOfAI/assets/110129950/f76483f7-fe9f-4c48-8e66-bc8ab8d8d360


1Ô∏è‚É£ Definici√≥n de CNN ü§ñ
Las Redes Neuronales Convolucionales son un tipo especializado de red neuronal dise√±ada principalmente para procesar datos con estructura de cuadr√≠cula, como im√°genes. Se inspiran en el procesamiento visual del cerebro humano y son muy eficaces en tareas de visi√≥n por computador. üëÅÔ∏è‚Äçüó®Ô∏è

2Ô∏è‚É£ Componentes principales de una CNN üß±
a) Capa de entrada: Recibe la imagen como tensor 3D
b) Capas convolucionales: Aplican filtros para detectar caracter√≠sticas
c) Funciones de activaci√≥n: Introducen no-linealidad (t√≠picamente ReLU)
d) Capas de pooling: Reducen la dimensionalidad espacial
e) Capa de aplanamiento: Convierte datos en vector unidimensional
f) Capas completamente conectadas: Realizan la clasificaci√≥n final
g) Capa de salida: Produce la predicci√≥n final

3Ô∏è‚É£ Proceso de convoluci√≥n üîÑ
- Operaci√≥n fundamental en CNNs
- Un filtro se desliza sobre la imagen de entrada
- Multiplicaci√≥n elemento por elemento y suma del resultado
- Crea un mapa de caracter√≠sticas que resalta patrones espec√≠ficos

4Ô∏è‚É£ Caracter√≠sticas clave de las CNNs üîë
a) Conectividad local: Cada neurona se conecta solo a una regi√≥n local
b) Compartici√≥n de par√°metros: Mismos pesos en m√∫ltiples ubicaciones
c) Invariancia a la traslaci√≥n: Detectan caracter√≠sticas independientemente de su posici√≥n

### Recursos para Explorar M√°s:

- **[funcionamiento de las redes neuronales convolucionales](https://youtu.be/4sWhhQwHqug?si=qvxBksruxjAbWVkC)** 
- **[¬°Redes Neuronales CONVOLUCIONALES! ¬øC√≥mo funcionan?](https://youtu.be/V8j1oENVz00?si=1PNlj6GPLEqP66sZ)**

---

# D√≠a14
----
## ¬øC√≥mo funcionan las CNNs en comparaci√≥n con las ANNs? ü§îüîç
Vamos a explorar c√≥mo funcionan las Redes Neuronales Convolucionales (CNNs) en comparaci√≥n con las Redes Neuronales Artificiales (ANNs). Ambas son arquitecturas importantes en el campo del aprendizaje profundo, pero tienen diferencias clave en su estructura y funcionamiento. ¬°Vamos a analizarlas! üß†üìä

### Redes Neuronales Artificiales (ANNs):

Las Redes Neuronales Artificiales (ANNs), tambi√©n conocidas como perceptrones multicapa, son una arquitectura cl√°sica de redes neuronales que consiste en m√∫ltiples capas de neuronas artificiales interconectadas. Cada neurona en una capa est√° conectada a todas las neuronas de la capa siguiente, lo que permite una representaci√≥n compleja de funciones no lineales.

**Funcionamiento:**
1. **Propagaci√≥n hacia Adelante (Forward Propagation):** Durante la propagaci√≥n hacia adelante, los datos de entrada se alimentan a trav√©s de la red neuronal, capa por capa, y se calculan las activaciones de cada neurona utilizando una combinaci√≥n lineal de las entradas y pesos, seguida de una funci√≥n de activaci√≥n no lineal.

2. **C√°lculo del Error:** Despu√©s de la propagaci√≥n hacia adelante, se compara la salida predicha de la red con la salida deseada utilizando una funci√≥n de p√©rdida, y se calcula el error de predicci√≥n.

3. **Propagaci√≥n hacia Atr√°s (Backward Propagation):** Durante la propagaci√≥n hacia atr√°s, el error calculado se propaga hacia atr√°s a trav√©s de la red para ajustar los pesos de cada neurona, utilizando algoritmos de optimizaci√≥n como el descenso de gradiente estoc√°stico (SGD).

### Redes Neuronales Convolucionales (CNNs):

Las Redes Neuronales Convolucionales (CNNs) son una variante especializada de las ANNs dise√±adas espec√≠ficamente para el procesamiento de im√°genes. Integran capas convolucionales que aplican filtros a las im√°genes de entrada para extraer caracter√≠sticas relevantes de manera eficiente.

**Principales Diferencias:**
1. **Estructura:** Mientras que las ANNs est√°n completamente conectadas, las CNNs utilizan capas convolucionales y de pooling para operar directamente sobre las caracter√≠sticas de la imagen, lo que reduce dr√°sticamente el n√∫mero de par√°metros y la complejidad computacional.

2. **Convoluci√≥n:** Las CNNs utilizan operaciones de convoluci√≥n para detectar caracter√≠sticas locales en las im√°genes, lo que les permite capturar patrones espaciales y de proximidad que son fundamentales en tareas de visi√≥n por computadora.

3. **Par√°metros Compartidos:** En las CNNs, los mismos pesos de filtro se comparten en diferentes regiones de la imagen, lo que les permite generalizar y aprender patrones independientemente de su ubicaci√≥n en la imagen.

### Aplicaciones:
- Las ANNs son m√°s adecuadas para tareas de aprendizaje supervisado en datos tabulares o secuenciales.
- Las CNNs son ideales para tareas de visi√≥n por computadora, como reconocimiento de objetos, detecci√≥n de objetos, segmentaci√≥n sem√°ntica y m√°s.

### Recursos para Explorar M√°s:
- **[CNN vs RNN vs ANN: Explicando las redes neuronales](https://www.linkedin.com/advice/0/how-do-you-explain-concepts-intuitions-behind?lang=es&originalSubdomain=es)**.


---
# D√≠a15
---
## Ejemplos Pr√°cticos de Aplicaci√≥n en la Industria üè≠ü§ñ

Vamos a explorar algunos ejemplos pr√°cticos de c√≥mo se aplican las redes neuronales convolucionales (CNNs) en la industria. Las CNNs son una poderosa herramienta en el campo del aprendizaje profundo, especialmente en aplicaciones de visi√≥n por computadora. Veamos algunos ejemplos interesantes:


https://github.com/Oliver369X/100DaysOfAI/assets/110129950/996d7620-d10f-40dd-b6ae-329945c07cd0


#### 1. Diagn√≥stico M√©dico:
- **Detecci√≥n de C√°ncer de Mama:** Las CNNs pueden analizar im√°genes de mamograf√≠as para detectar signos tempranos de c√°ncer de mama, ayudando a los m√©dicos en el diagn√≥stico precoz y la planificaci√≥n del tratamiento.

#### 2. Automatizaci√≥n Industrial:
- **Inspecci√≥n de Calidad en Manufactura:** Las CNNs pueden inspeccionar visualmente productos manufacturados en busca de defectos o imperfecciones, garantizando la calidad del producto final y reduciendo el desperdicio.

#### 3. Automotriz y Conducci√≥n Aut√≥noma:
- **Detecci√≥n de Peatones y Objetos:** Las CNNs integradas en sistemas de conducci√≥n aut√≥noma pueden identificar peatones, veh√≠culos y otros objetos en tiempo real, permitiendo que los veh√≠culos tomen decisiones de conducci√≥n seguras.

#### 4. Agricultura de Precisi√≥n:
- **Monitoreo de Cultivos:** Las CNNs pueden analizar im√°genes satelitales para monitorear el crecimiento de los cultivos, identificar √°reas de estr√©s vegetal y optimizar el uso de recursos agr√≠colas como el agua y los fertilizantes.

#### 5. Seguridad y Vigilancia:
- **Reconocimiento Facial y de Objeto:** Las CNNs pueden analizar im√°genes de c√°maras de seguridad para identificar caras de inter√©s, detectar intrusiones no autorizadas y alertar sobre actividades sospechosas.

#### 6. Retail y Experiencia del Cliente:
- **Personalizaci√≥n de Recomendaciones:** Las CNNs pueden analizar el historial de compras y las preferencias del cliente para ofrecer recomendaciones de productos altamente personalizadas, mejorando la experiencia de compra en l√≠nea.

## Recursos sobre Aplicaciones Pr√°cticas de Redes Neuronales Convolucionales (CNNs):

### **1. Diagn√≥stico M√©dico:**

* **Detecci√≥n de C√°ncer de Mama:**
    * **Art√≠culo:** "Aplicaci√≥n de redes neuronales convolucionales para la detecci√≥n de c√°ncer de mama en im√°genes de mamograf√≠a" ([https://revistascientificas.cuc.edu.co/CESTA/article/view/3922/3919](https://revistascientificas.cuc.edu.co/CESTA/article/view/3922/3919))
    * **Video:** "Redes Neuronales Convolucionales para Detecci√≥n de C√°ncer de Mama" ([https://www.youtube.com/watch?v=06TugnwqZCQ](https://www.youtube.com/watch?v=06TugnwqZCQ))

### **2. Automatizaci√≥n Industrial:**

* **Inspecci√≥n de Calidad en Manufactura:**
    * **Art√≠culo:** "Inspecci√≥n de defectos en productos manufacturados utilizando redes neuronales convolucionales" ([http://www.scielo.org.co/scielo.php?script=sci_arttext&pid=S0121-750X2023000100204](http://www.scielo.org.co/scielo.php?script=sci_arttext&pid=S0121-750X2023000100204))
    * **Video:** "Automatizaci√≥n de la Inspecci√≥n Visual en la Industria Manufacturera con Redes Neuronales Convolucionales" ([https://www.youtube.com/watch?v=FkvWe00Pjgs](https://www.youtube.com/watch?v=FkvWe00Pjgs))

### **3. Automotriz y Conducci√≥n Aut√≥noma:**

* **Detecci√≥n de Peatones y Objetos:**

    * **Video:** "Visi√≥n Artificial para Veh√≠culos Aut√≥nomos: Detecci√≥n de Peatones y Objetos con Redes Neuronales Convolucionales" ([https://www.youtube.com/watch?v=WC8dm4dxqPw](https://www.youtube.com/watch?v=WC8dm4dxqPw))

---

# D√≠a16
---
## Comprendiendo la Convoluci√≥n en Im√°genes üì∏üîç


https://github.com/Oliver369X/100DaysOfAI/assets/110129950/65915ade-08c5-47b8-8b9b-85dbc69435f8


#### ¬øQu√© es la Convoluci√≥n?
La convoluci√≥n es una operaci√≥n matem√°tica fundamental en el procesamiento de se√±ales y el aprendizaje profundo. En el contexto de las im√°genes, la convoluci√≥n implica deslizar una peque√±a ventana (llamada kernel o filtro) sobre la imagen de entrada y realizar operaciones matem√°ticas en cada regi√≥n de la imagen.

#### Aplicaci√≥n en Im√°genes:
- **Extracci√≥n de Caracter√≠sticas:** La convoluci√≥n se utiliza para extraer caracter√≠sticas importantes de una imagen, como bordes, texturas y patrones, mediante la detecci√≥n de caracter√≠sticas locales en diferentes partes de la imagen.
- **Reducci√≥n de Dimensionalidad:** Al aplicar convoluciones sucesivas con diferentes filtros, se obtienen mapas de caracter√≠sticas que resumen la informaci√≥n clave de la imagen, lo que permite una representaci√≥n m√°s compacta y manejable para la red neuronal.
- **Detecci√≥n de Objetos:** En el contexto del aprendizaje profundo, las convoluciones son fundamentales en las arquitecturas de redes neuronales convolucionales (CNNs) para la detecci√≥n y clasificaci√≥n de objetos en im√°genes.

#### Proceso de Convoluci√≥n:
1. **Deslizamiento del Kernel:** El kernel se desliza sobre la imagen de entrada, multiplicando sus valores por los p√≠xeles correspondientes en cada regi√≥n.
2. **Operaci√≥n de Producto Punto:** Se calcula el producto punto entre los valores del kernel y los p√≠xeles de la regi√≥n de la imagen.
3. **Suma y Bias:** Se suman los resultados de la operaci√≥n de producto punto y se agrega un t√©rmino de sesgo (bias).
4. **Aplicaci√≥n de Funci√≥n de Activaci√≥n:** Opcionalmente, se aplica una funci√≥n de activaci√≥n no lineal, como ReLU, para introducir no linealidades en la red.

### Recursos para Explorar M√°s:
- **[La CONVOLUCI√ìN en las REDES CONVOLUCIONALES](https://youtu.be/ySbmdeqR0-4?si=_lp6W3jjBWVu0E5e)**.
- **[Convoluciones y filtros](https://youtu.be/AwTH_0yW9_I?si=2EuPLMROMmReZR1T)**.

---

# D√≠a17
---
## Entendiendo los Filtros y su Papel en la Extracci√≥n de Caracter√≠sticas üåüüîç


https://github.com/Oliver369X/100DaysOfAI/assets/110129950/15eb563d-a718-4ab5-9153-42a19c8839e1


Hoy vamos a explorar m√°s a fondo los filtros en el contexto de las redes neuronales convolucionales (CNNs) y c√≥mo desempe√±an un papel crucial en la extracci√≥n de caracter√≠sticas de las im√°genes.

#### ¬øQu√© son los Filtros en CNNs?
Los filtros, tambi√©n conocidos como kernels, son matrices peque√±as de pesos que se utilizan en las capas convolucionales de las CNNs. Cada filtro se desliza sobre la imagen de entrada y realiza operaciones de convoluci√≥n para extraer caracter√≠sticas espec√≠ficas.

#### Funci√≥n de los Filtros:
- **Detecci√≥n de Caracter√≠sticas:** Cada filtro est√° dise√±ado para detectar una caracter√≠stica espec√≠fica en la imagen, como bordes, texturas, formas o patrones.
- **Aprendizaje de Caracter√≠sticas:** Durante el entrenamiento de la red neuronal, los valores de los filtros se ajustan autom√°ticamente para aprender las caracter√≠sticas m√°s relevantes para la tarea espec√≠fica.

#### Proceso de Extracci√≥n de Caracter√≠sticas:
1. **Convoluci√≥n:** El filtro se aplica a la imagen de entrada mediante la operaci√≥n de convoluci√≥n, multiplicando sus valores por los p√≠xeles correspondientes y sumando los resultados.
2. **Mapa de Activaci√≥n:** La salida de la convoluci√≥n se conoce como mapa de activaci√≥n, que resalta la presencia de la caracter√≠stica detectada en diferentes regiones de la imagen.
3. **Pooling:** Opcionalmente, se puede aplicar una capa de pooling despu√©s de la convoluci√≥n para reducir la dimensionalidad y mejorar la eficiencia computacional.



#### Importancia en el Aprendizaje Profundo:
- Los filtros son esenciales para el aprendizaje profundo, ya que permiten que la red neuronal aprenda representaciones jer√°rquicas de las caracter√≠sticas de las im√°genes.
- Al apilar capas convolucionales con diferentes filtros, la red puede aprender caracter√≠sticas cada vez m√°s abstractas y complejas, lo que mejora su capacidad para realizar tareas de visi√≥n por computadora.


### Recursos para Explorar M√°s:
- **[Filtros espaciales aplicados a im√°genes](https://youtu.be/K9Tx4NOWUSg?si=4UdJDFUQuzCJRTJJ)**.

---

# D√≠a18
---
## Stride y Padding en CNNs üö∂üèª‚Äç‚ôÇÔ∏èüõå

Hoy vamos a explorar dos conceptos importantes en las redes neuronales convolucionales (CNNs): Stride y Padding. Estos conceptos son fundamentales para el dise√±o y la configuraci√≥n de las capas convolucionales.

#### Stride:
- **Definici√≥n:** El stride (paso) es la cantidad de p√≠xeles que el filtro se desplaza en cada paso mientras se aplica a la imagen de entrada.
- **Efecto:** Un stride mayor reduce la dimensi√≥n espacial de la salida (mapa de activaci√≥n), ya que el filtro se mueve m√°s r√°pido a lo largo de la imagen.
- **Control de Dimensionalidad:** El stride se utiliza para controlar la reducci√≥n de dimensionalidad en las capas convolucionales, lo que puede ser √∫til para reducir el costo computacional y el overfitting.

#### Padding:
- **Definici√≥n:** El padding (relleno) consiste en agregar p√≠xeles adicionales alrededor de la imagen de entrada antes de aplicar la convoluci√≥n.
- **Uso:** El padding se utiliza para mantener la dimensi√≥n espacial de la salida despu√©s de la convoluci√≥n, especialmente en los bordes de la imagen.
- **Beneficios:** Al agregar padding, se conserva m√°s informaci√≥n espacial de la imagen de entrada y se evita la p√©rdida de caracter√≠sticas en los bordes.
- **Tipos de Padding:** Se pueden utilizar diferentes tipos de padding, como "same" (mismo tama√±o de entrada y salida) o "valid" (sin relleno), seg√∫n los requisitos de la arquitectura de la red.




#### Importancia en las CNNs:
- El stride y el padding son par√°metros importantes que afectan la dimensi√≥n espacial de la salida y la cantidad de informaci√≥n preservada.
- Ajustar adecuadamente el stride y el padding puede mejorar el rendimiento y la eficiencia de la red neuronal convolucional en tareas de visi√≥n por computadora.

### Recursos para Explorar M√°s:
- **[Padding, strides, max pooling y stacking en las REDES CONVOLUCIONALES](https://youtu.be/QLy8v6LL_4A?si=6ElSwovGCi-Eljj3)**.

---

# D√≠a19
---
## Pooling en CNNs üèä‚Äç‚ôÇÔ∏èüîç

¬°Hola a todos! Hoy vamos a explorar una t√©cnica fundamental en las redes neuronales convolucionales (CNNs): el Pooling. El Pooling es una operaci√≥n importante para la reducci√≥n de dimensionalidad y la extracci√≥n de caracter√≠sticas en las CNNs.

![Pooling](https://github.com/Oliver369X/100DaysOfAI/assets/110129950/9e06b087-f42c-4ce3-af88-cbfc80ce9d82)
![pooling](https://github.com/Oliver369X/100DaysOfAI/assets/110129950/38bc0a1a-fc89-4c66-94d4-5c43a2443bb9)

#### Introducci√≥n al Pooling:
- **Definici√≥n:** El Pooling es una operaci√≥n que reduce la dimensionalidad de cada mapa de activaci√≥n, conservando solo la informaci√≥n m√°s importante.
- **Tipos de Pooling:** Los tipos comunes de Pooling son el Max Pooling y el Average Pooling.
- **Funcionamiento:** En el Max Pooling, se selecciona el valor m√°ximo de un √°rea definida en el mapa de activaci√≥n. En el Average Pooling, se calcula el promedio de los valores en el √°rea especificada.
- **Reducci√≥n de Dimensionalidad:** El Pooling reduce el tama√±o espacial de la entrada, lo que disminuye el n√∫mero de par√°metros y operaciones en la red neuronal.

#### Impacto en las CNNs:
- **Reducci√≥n de Overfitting:** Al reducir la dimensionalidad, el Pooling ayuda a prevenir el overfitting al eliminar informaci√≥n redundante y mejorar la generalizaci√≥n del modelo.
- **Invariancia a las Transformaciones:** El Pooling hace que la red sea m√°s invariante a peque√±as traslaciones y deformaciones en las caracter√≠sticas detectadas.
- **Extracci√≥n de Caracter√≠sticas:** Al conservar solo las caracter√≠sticas m√°s importantes, el Pooling facilita la identificaci√≥n de patrones relevantes en los mapas de activaci√≥n.



En la imagen de arriba, se muestra un ejemplo de Max Pooling aplicado a un mapa de activaci√≥n. La regi√≥n de 2x2 se desliza sobre el mapa, seleccionando el valor m√°ximo en cada regi√≥n para formar la salida.

### Recursos para Explorar M√°s:
- **[CNN vs RNN vs ANN: Explicando las redes neuronales](https://www.linkedin.com/advice/0/how-do-you-explain-concepts-intuitions-behind?lang=es&originalSubdomain=es)**.
- **[Capas de pooling en una red neuronal convolucional](https://keepcoding.io/blog/capas-pooling-red-neuronal-convolucional/)**.
- **[Pooling and their types in CNN
](https://medium.com/@abhishekjainindore24/pooling-and-their-types-in-cnn-4a4b8a7a4611)**.

---

# D√≠a20
---
##  Funciones de Activaci√≥n

- **Definici√≥n**: Las funciones de activaci√≥n son componentes cruciales en las redes neuronales que introducen no-linealidad en el modelo.
 - **Prop√≥sito**: Permiten a la red aprender y aproximar funciones complejas.
- **Importancia**: Sin ellas, la red ser√≠a equivalente a un modelo lineal simple.

#### ReLU (Rectified Linear Unit)
**Definici√≥n Matem√°tica**: f(x) = max(0, x)
**Funcionamiento**:
- Si la entrada es negativa, la salida es 0.
- Si la entrada es positiva, la salida es igual a la entrada.
**Ventajas**:
- Reduce el problema del desvanecimiento del gradiente.
- Computacionalmente eficiente.
- Converge m√°s r√°pido que las funciones sigmoide o tangente hiperb√≥lica.
**Desventajas**:
- Problema de "neuronas muertas": si una neurona siempre produce salidas negativas, puede "morir" y dejar de aprender.

#### LeakyReLU
**Definici√≥n Matem√°tica**: f(x) = max(Œ±x, x), donde Œ± es un valor peque√±o (t√≠picamente 0.01).
**Funcionamiento**:
- Similar a ReLU, pero permite un peque√±o gradiente negativo cuando la unidad no est√° activa.
**Ventajas sobre ReLU**:
- Evita el problema de las neuronas muertas.
- Permite un peque√±o flujo de gradientes negativos.
**C√≥mo elegir el valor de Œ±**:
- Generalmente se usa 0.01, pero puede ser un hiperpar√°metro a optimizar.

#### Otras Variantes de ReLU
**a) PReLU (Parametric ReLU)**
- Similar a LeakyReLU, pero Œ± es un par√°metro aprendible.
- Puede adaptarse mejor a los datos espec√≠ficos del problema.

**b) ELU (Exponential Linear Unit)**
- **Definici√≥n**: f(x) = x si x > 0, Œ±(exp(x) - 1) si x ‚â§ 0.
- Produce salidas negativas suaves, lo que puede ayudar a empujar las activaciones medias m√°s cerca de cero.

#### Implementaci√≥n Pr√°ctica
**En TensorFlow/Keras**:
```python
from tensorflow.keras.layers import ReLU, LeakyReLU

# ReLU
model.add(ReLU())

# LeakyReLU
model.add(LeakyReLU(alpha=0.01))
```

**En PyTorch**:
```python
import torch.nn as nn

# ReLU
model.add_module('relu', nn.ReLU())

# LeakyReLU
model.add_module('leaky_relu', nn.LeakyReLU(negative_slope=0.01))
```

#### Consideraciones al Elegir Funciones de Activaci√≥n
- Depende del problema espec√≠fico y la arquitectura de la red.
- ReLU es una buena opci√≥n por defecto para capas ocultas.
- Para la capa de salida, la elecci√≥n depende del tipo de problema (por ejemplo, softmax para clasificaci√≥n multiclase).

### Recursos para Explorar M√°s:
- **[La FUNCI√ìN DE ACTIVACI√ìN
](https://youtu.be/lFODTDO8mMw?si=XZ0tsIUvYpqrtVzz)**.
- **[Funciones de Activaci√≥n ‚Äì Fundamentos de Deep Learning ](https://youtu.be/IdlYuBKeFXo?si=5RwnIieB0vBf-3o0)**.
- **[Clase 5 - Deep Learning - Funciones de activaci√≥n: ReLU, Softmax](https://youtu.be/psVhj3Y8_rw?si=dzM13mjw1a_kc7cl)**.

---
# D√≠a21
---
## Construcci√≥n de Capas en CNNs üõ†Ô∏èüß±

### Construcci√≥n de Capas Convolucionales: üîç
* **Definici√≥n:** Las capas convolucionales son fundamentales en las CNNs para la detecci√≥n de caracter√≠sticas en datos de alta dimensi√≥n, como im√°genes.
* **Operaci√≥n de Convoluci√≥n:** La operaci√≥n de convoluci√≥n aplica un filtro (o kernel) a una regi√≥n de la entrada, produciendo un mapa de activaci√≥n que resalta ciertas caracter√≠sticas.
* **Par√°metros:** Las capas convolucionales tienen par√°metros que se aprenden durante el entrenamiento de la red, lo que permite adaptarse a patrones espec√≠ficos en los datos de entrada.
* **Construcci√≥n de Capas:** En la construcci√≥n de una capa convolucional, se especifican el n√∫mero de filtros, el tama√±o del filtro, el paso (stride) y el tipo de relleno (padding) para controlar la salida de la capa.

```python
import tensorflow as tf

inputs = tf.keras.Input(shape=(28, 28, 1))
x = tf.keras.layers.Conv2D(32, (3, 3), activation='relu', padding='same')(inputs)
```

### Construcci√≥n de Capas de Pooling: üîΩ
* **Reducci√≥n de Dimensionalidad:** Las capas de pooling reducen la dimensionalidad de los mapas de activaci√≥n, manteniendo las caracter√≠sticas m√°s importantes.
* **Operaci√≥n de Pooling:** El Max Pooling y el Average Pooling son operaciones comunes en las capas de pooling, que seleccionan el valor m√°ximo o calculan el promedio en una regi√≥n definida.
* **Conexi√≥n con Capas Convolutivas:** Las capas de pooling suelen seguir a las capas convolucionales para reducir la resoluci√≥n espacial y el n√∫mero de par√°metros.

```python
x = tf.keras.layers.MaxPooling2D((2, 2))(x)
```

### Conexi√≥n de Capas y Formaci√≥n de una Red Profunda: üèóÔ∏è
* **Construcci√≥n de la Red:** Las capas convolucionales y de pooling se apilan para formar una red profunda. La conexi√≥n entre estas capas permite que la red aprenda representaciones jer√°rquicas de los datos.
* **Apilamiento de Capas:** Las capas convolucionales y de pooling se apilan secuencialmente, seguidas a menudo por capas totalmente conectadas (densas) para la clasificaci√≥n final.

```python
x = tf.keras.layers.Conv2D(64, (3, 3), activation='relu', padding='same')(x)
x = tf.keras.layers.MaxPooling2D((2, 2))(x)
x = tf.keras.layers.Flatten()(x)
x = tf.keras.layers.Dense(64, activation='relu')(x)
outputs = tf.keras.layers.Dense(10, activation='softmax')(x)

model = tf.keras.Model(inputs=inputs, outputs=outputs)

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])
```


### Recursos para Explorar M√°s:
- **[¬øQu√© es una red neuronal convolucional (CNN) y qu√© capas tiene?](https://youtu.be/3u3wW4T4sSA?si=cud0FqPhhwFwkvnR)**.
- **[Capas convolucionales y de pooling
](https://youtu.be/oTjzC8yxrRs?si=ijO9X7zFowr4j2Gp)**.

---

# D√≠a22
---
## Capas Completamente Conectadas (Fully Connected Layers) üîóü§ñ

#### Integraci√≥n de Capas Completamente Conectadas:
- **Definici√≥n:** Las capas completamente conectadas, tambi√©n conocidas como capas densas, son aquellas donde cada neurona est√° conectada a todas las neuronas de la capa anterior.
- **Transformaci√≥n de Datos:** Despu√©s de varias capas convolucionales y de pooling, las caracter√≠sticas extra√≠das se aplanan en un vector de una dimensi√≥n antes de ser alimentadas a las capas completamente conectadas.
- **Funci√≥n:** Estas capas combinan las caracter√≠sticas aprendidas para tomar decisiones finales. Son esenciales para tareas de clasificaci√≥n y regresi√≥n.

#### Uso en la Fase de Clasificaci√≥n Final:
- **Proceso de Clasificaci√≥n:** En una CNN t√≠pica, despu√©s de que las capas convolucionales y de pooling han extra√≠do y reducido las caracter√≠sticas, las capas completamente conectadas procesan esta informaci√≥n para realizar la clasificaci√≥n final.
- **Softmax y Activaciones:** La √∫ltima capa completamente conectada en un modelo de clasificaci√≥n suele utilizar una funci√≥n de activaci√≥n softmax para convertir las salidas en probabilidades de las diferentes clases.
- **Entrenamiento:** Durante el entrenamiento, los pesos de las capas completamente conectadas se ajustan para minimizar la funci√≥n de p√©rdida, mejorando la precisi√≥n de las predicciones.

#### Estructura de una CNN con Capas Completamente Conectadas:
- **Capas Iniciales:** Varias capas convolucionales y de pooling para extraer caracter√≠sticas.
- **Aplanamiento:** Transformaci√≥n de los mapas de caracter√≠sticas en un vector de una dimensi√≥n.
- **Capas Densas:** Una o m√°s capas completamente conectadas que procesan el vector de caracter√≠sticas.
- **Clasificaci√≥n Final:** Una capa completamente conectada final con softmax para la salida de clasificaci√≥n.

Las capas completamente conectadas juegan un papel crucial en la toma de decisiones finales de una CNN, integrando todas las caracter√≠sticas aprendidas y proporcionando la salida del modelo.
### Recursos para Explorar M√°s:
- **[Capa totalmente conectada](https://es.mathworks.com/help/deeplearning/ref/nnet.cnn.layer.fullyconnectedlayer.html)**.
- **[Fully Connected Layer
](https://medium.com/@vaibhav1403/fully-connected-layer-f13275337c7c)**.
- **[Layer (deep learning)
](https://en.wikipedia.org/wiki/Layer_(deep_learning))**.


---
# D√≠a23
---
## Regularizaci√≥n en CNNs üìöüõ°Ô∏è

¬°Hola a todos! Hoy, en el d√≠a 23 de nuestro desaf√≠o #100DaysOfAI, vamos a explorar las **t√©cnicas de regularizaci√≥n en CNNs**. Estas t√©cnicas son esenciales para prevenir el overfitting y asegurar que nuestros modelos generalicen bien en datos no vistos. ¬°Vamos a sumergirnos en ellas!

#### ¬øQu√© es la Regularizaci√≥n?

La regularizaci√≥n en redes neuronales y, espec√≠ficamente, en CNNs, se refiere a un conjunto de t√©cnicas utilizadas para reducir el error en un conjunto de datos de prueba que es diferente del conjunto de datos de entrenamiento. En t√©rminos sencillos, ayuda a nuestro modelo a no "memorizar" el conjunto de entrenamiento y a ser capaz de generalizar bien en datos nuevos.


#### T√©cnicas de Regularizaci√≥n en CNNs

1. **Dropout**

   Dropout es una t√©cnica muy popular para prevenir el overfitting. Implica "desconectar" aleatoriamente algunas neuronas durante el entrenamiento. Esto fuerza a la red a no depender demasiado de ninguna neurona espec√≠fica y a aprender representaciones m√°s robustas.

   **C√≥mo Implementar Dropout:**
   ```python
   from tensorflow.keras.layers import Dropout, Dense

   model = Sequential()
   model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
   model.add(MaxPooling2D((2, 2)))
   model.add(Conv2D(64, (3, 3), activation='relu'))
   model.add(MaxPooling2D((2, 2)))
   model.add(Flatten())
   model.add(Dense(128, activation='relu'))
   model.add(Dropout(0.5))  # Aplicar Dropout con 50% de neuronas desconectadas
   model.add(Dense(10, activation='softmax'))
   ```

2. **Data Augmentation**

   La augmentaci√≥n de datos es una t√©cnica en la que se generan nuevas muestras de datos a partir de los datos existentes aplicando transformaciones como rotaciones, desplazamientos, cambios de escala, etc. Esto ayuda a que el modelo vea una mayor diversidad de datos durante el entrenamiento y mejore su capacidad de generalizaci√≥n.

   **C√≥mo Implementar Data Augmentation:**
   ```python
   from tensorflow.keras.preprocessing.image import ImageDataGenerator

   datagen = ImageDataGenerator(
       rotation_range=20,
       width_shift_range=0.2,
       height_shift_range=0.2,
       shear_range=0.2,
       zoom_range=0.2,
       horizontal_flip=True,
       fill_mode='nearest'
   )

   datagen.fit(X_train)
   model.fit(datagen.flow(X_train, y_train, batch_size=32), epochs=50)
   ```

3. **Regularizaci√≥n L2 (Weight Decay)**

   La regularizaci√≥n L2 a√±ade una penalizaci√≥n a la funci√≥n de p√©rdida basada en el tama√±o de los pesos. Esta t√©cnica desincentiva que los pesos crezcan demasiado, lo cual puede ayudar a prevenir el overfitting.

   **C√≥mo Implementar L2 Regularization:**
   ```python
   from tensorflow.keras.regularizers import l2

   model = Sequential()
   model.add(Conv2D(32, (3, 3), activation='relu', kernel_regularizer=l2(0.01), input_shape=(28, 28, 1)))
   model.add(MaxPooling2D((2, 2)))
   model.add(Conv2D(64, (3, 3), activation='relu', kernel_regularizer=l2(0.01)))
   model.add(MaxPooling2D((2, 2)))
   model.add(Flatten())
   model.add(Dense(128, activation='relu', kernel_regularizer=l2(0.01)))
   model.add(Dense(10, activation='softmax'))
   ```

4. **Batch Normalization**

   La normalizaci√≥n por lotes (Batch Normalization) es una t√©cnica que normaliza las activaciones de una capa para cada mini-lote. Esto acelera el entrenamiento y puede tener un efecto regularizador.

   **C√≥mo Implementar Batch Normalization:**
   ```python
   from tensorflow.keras.layers import BatchNormalization

   model = Sequential()
   model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))
   model.add(BatchNormalization())  # Aplicar Batch Normalization
   model.add(MaxPooling2D((2, 2)))
   model.add(Conv2D(64, (3, 3), activation='relu'))
   model.add(BatchNormalization())
   model.add(MaxPooling2D((2, 2)))
   model.add(Flatten())
   model.add(Dense(128, activation='relu'))
   model.add(BatchNormalization())
   model.add(Dense(10, activation='softmax'))
   ```

---

### Recursos Adicionales

1. **[Regularizaci√≥n L2 y Dropout](https://youtu.be/DVpiSJVMOVo?si=As8auc_DjMfi-sKZ)**
2. **[Dropout: A Simple Way to Prevent Neural Networks from Overfitting (JMLR)](http://jmlr.org/papers/volume15/srivastava14a/srivastava14a.pdf)**
3. **[Image Augmentation for Deep Learning with Keras](https://machinelearningmastery.com/how-to-configure-image-data-augmentation-when-training-deep-learning-neural-networks/)**
4. **[Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift (arXiv)](https://arxiv.org/abs/1502.03167)**


---
# D√≠a24

---

## C√≥mo Funciona el Backpropagation en las CNNs üß†üîÑ

### ¬øQu√© es el Backpropagation?
- **Definici√≥n:** El backpropagation, o retropropagaci√≥n, es un algoritmo utilizado para ajustar los pesos de una red neuronal durante el entrenamiento, permitiendo que la red aprenda al minimizar la funci√≥n de p√©rdida.
- **Proceso:** Involucra dos fases principales: la propagaci√≥n hacia adelante (forward propagation) y la propagaci√≥n hacia atr√°s (backward propagation).

### Propagaci√≥n Hacia Adelante (Forward Propagation)
- **Paso Inicial:** Los datos de entrada se pasan a trav√©s de la red capa por capa.
- **C√°lculo de la P√©rdida:** Se obtiene una predicci√≥n que se compara con la etiqueta real para calcular la p√©rdida usando una funci√≥n de p√©rdida.

### Propagaci√≥n Hacia Atr√°s (Backward Propagation)
- **C√°lculo del Gradiente:** Se calcula el gradiente de la funci√≥n de p√©rdida con respecto a cada peso usando la regla de la cadena, indicando c√≥mo cambiar los pesos para reducir la p√©rdida.
- **Ajuste de Pesos:** Los pesos se actualizan en la direcci√≥n opuesta al gradiente para minimizar la funci√≥n de p√©rdida, usando un optimizador como el descenso de gradiente.

### Backpropagation en CNNs
1. **C√°lculo de la P√©rdida:**
   - La p√©rdida se calcula despu√©s de la fase de forward propagation, que implica pasar la imagen de entrada a trav√©s de capas convolucionales, de pooling y completamente conectadas.
2. **C√°lculo del Gradiente en Capas Completamente Conectadas:**
   - Similar a una red neuronal est√°ndar, se calculan los gradientes de la p√©rdida con respecto a los pesos y sesgos en las capas completamente conectadas.
3. **C√°lculo del Gradiente en Capas Convolucionales:**
   - Los gradientes se calculan con respecto a los filtros convolucionales, propag√°ndose hacia atr√°s a trav√©s de las operaciones de convoluci√≥n y pooling.
   - **Convoluci√≥n Transpuesta:** Se realiza una operaci√≥n de convoluci√≥n transpuesta (deconvoluci√≥n) para calcular el gradiente con respecto a los filtros.
4. **Actualizaci√≥n de Pesos:**
   - Los pesos y filtros en todas las capas se actualizan usando los gradientes calculados, repitiendo el proceso hasta que la funci√≥n de p√©rdida se minimice adecuadamente.

### Resumen del Proceso
1. **Forward Propagation:** Pasar los datos de entrada a trav√©s de la red para obtener una predicci√≥n.
2. **C√°lculo de la P√©rdida:** Comparar la predicci√≥n con la etiqueta real y calcular la p√©rdida.
3. **Backward Propagation:** Calcular los gradientes de la p√©rdida con respecto a los pesos y filtros.
4. **Actualizaci√≥n de Pesos:** Ajustar los pesos y filtros en la direcci√≥n opuesta a los gradientes.

### Recursos para Explorar M√°s:
- **[C√≥mo ven el mundo las redes neuronales convolucionales](https://blog.keras.io/how-convolutional-neural-networks-see-the-world.html)**.
- - **[Backpropagation en CNNs](https://youtu.be/kDUe0RuONYo?si=7HSe8JjALmR_oW-K)**.
---
# D√≠a25
---
## Actualizaci√≥n de Pesos y Ajuste de Filtros üõ†Ô∏èüîÑ


#### Actualizaci√≥n de Pesos y Filtros en CNNs

1. **C√°lculo de Gradientes:**
  - Durante el proceso de backpropagation, calculamos los gradientes de la funci√≥n de p√©rdida con respecto a cada peso y filtro en la red. Estos gradientes nos indican en qu√© direcci√≥n y cu√°nto debemos ajustar los pesos y filtros para minimizar la p√©rdida.

2. **Uso de un Optimizador:**
  - **Descenso de Gradiente Estoc√°stico (SGD):** Es uno de los m√©todos m√°s comunes para actualizar los pesos. El SGD ajusta los pesos en la direcci√≥n opuesta a los gradientes con una tasa de aprendizaje definida.
   - **Optimizadores Avanzados:** Otros optimizadores como Adam, RMSprop y Adagrad tambi√©n se utilizan ampliamente. Estos optimizadores adaptan la tasa de aprendizaje para cada peso individualmente y pueden acelerar el proceso de convergencia.



3. **Actualizaci√≥n de Filtros:**
  - Similar a los pesos, los filtros en las capas convolucionales se actualizan usando los gradientes calculados durante backpropagation.
   - **Convoluci√≥n Transpuesta:** Se usa para propagar los gradientes a trav√©s de las capas convolucionales y calcular el ajuste necesario para los filtros.

4. **Normalizaci√≥n de Pesos:**
  - Para evitar problemas como el "vanishing gradient" o "exploding gradient", es importante normalizar los pesos. T√©cnicas como Batch Normalization se utilizan para estabilizar y acelerar el entrenamiento.

#### Ejemplo Pr√°ctico:

Imaginemos que estamos entrenando una CNN para clasificar im√°genes de gatos y perros. Durante el entrenamiento, cada imagen se pasa a trav√©s de m√∫ltiples capas convolucionales y de pooling. Despu√©s de cada pasada, calculamos la p√©rdida y luego los gradientes para cada peso y filtro.

Usamos un optimizador, digamos Adam, para ajustar los pesos y filtros de acuerdo a las f√≥rmulas mencionadas anteriormente. Este proceso se repite iterativamente hasta que la p√©rdida se minimice y la precisi√≥n del modelo se maximice.

#### Resumen:

1. **Forward Propagation:** Pasar los datos de entrada a trav√©s de la red.
2. **C√°lculo de P√©rdida:** Comparar la predicci√≥n con la etiqueta real.
3. **Backward Propagation:** Calcular los gradientes.
4. **Actualizaci√≥n de Pesos y Filtros:** Usar un optimizador para ajustar los pesos y filtros.

La actualizaci√≥n de pesos y el ajuste de filtros son fundamentales para el aprendizaje efectivo de las CNNs, permitiendo que el modelo mejore su precisi√≥n con el tiempo.

### Recursos para Explorar M√°s:
- **[¬øQu√© es una red neuronal convolucional (CNN) y qu√© capas tiene?](https://youtu.be/3u3wW4T4sSA?si=cud0FqPhhwFwkvnR)**.
---
# D√≠a26
---
Este proyecto tiene como objetivo desarrollar modelos de inteligencia artificial capaces de clasificar im√°genes de perros y gatos utilizando t√©cnicas avanzadas de aprendizaje profundo y aumentando los datos para mejorar la precisi√≥n del modelo. Utilizando TensorFlow y TensorFlow.js, se construyen y entrenan varios modelos neurales para lograr una clasificaci√≥n precisa y robusta.

### 1. **Importaci√≥n de bibliotecas y descarga del conjunto de datos**

```python
# Importar las bibliotecas necesarias
import tensorflow as tf
import tensorflow_datasets as tfds

# Correcci√≥n temporal para solucionar un error en la descarga del conjunto de datos
setattr(tfds.image_classification.cats_vs_dogs, '_URL',
        "https://download.microsoft.com/download/3/E/1/3E1C3F21-ECDB-4869-8368-6DEBA77B919F/kagglecatsanddogs_5340.zip")

# Descargar el conjunto de datos de perros y gatos
datos, metadatos = tfds.load('cats_vs_dogs', as_supervised=True, with_info=True)
```

Esta celda se encarga de:

- Importar las bibliotecas TensorFlow y TensorFlow Datasets.
- Aplicar una correcci√≥n temporal a la URL de descarga del conjunto de datos.
- Descargar el conjunto de datos de perros y gatos, junto con los metadatos.

### 2. **Visualizaci√≥n de metadatos**

```python
# Imprimir los metadatos para revisarlos
metadatos
```

Esta celda muestra los metadatos del conjunto de datos, proporcionando informaci√≥n sobre el mismo.

### 3. **Visualizaci√≥n de ejemplos del conjunto de datos (M√©todo 1)**

```python
# Una forma de mostrar 5 ejemplos del conjunto de datos
tfds.as_dataframe(datos['train'].take(5), metadatos)
```

Esta celda convierte 5 ejemplos del conjunto de datos de entrenamiento en un DataFrame para su visualizaci√≥n.

### 4. **Visualizaci√≥n de ejemplos del conjunto de datos (M√©todo 2)**

```python
# Otra forma de mostrar ejemplos del conjunto de datos
tfds.show_examples(datos['train'], metadatos)
```

Esta celda utiliza una funci√≥n de visualizaci√≥n incorporada para mostrar ejemplos del conjunto de datos de entrenamiento.

### 5. **Preprocesamiento y visualizaci√≥n de im√°genes**

```python
# Importar matplotlib para visualizaci√≥n y cv2 para manipulaci√≥n de im√°genes
import matplotlib.pyplot as plt
import cv2

# Establecer el tama√±o de la figura para la visualizaci√≥n
plt.figure(figsize=(20,20))

# Definir tama√±o de la imagen
TAMANO_IMG = 100

# Procesar y visualizar 25 im√°genes del conjunto de datos de entrenamiento
for i, (imagen, etiqueta) in enumerate(datos['train'].take(25)):
    # Redimensionar la imagen a 100x100 p√≠xeles
    imagen = cv2.resize(imagen.numpy(), (TAMANO_IMG, TAMANO_IMG))
    # Convertir la imagen a escala de grises
    imagen = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    # A√±adir la imagen al subplot correspondiente
    plt.subplot(5, 5, i + 1)
    plt.xticks([])  # Eliminar marcas del eje x
    plt.yticks([])  # Eliminar marcas del eje y
    plt.imshow(imagen, cmap='gray')  # Mostrar la imagen en escala de grises
plt.show()
```

Esta celda:

- Preprocesa las im√°genes redimension√°ndolas a 100x100 p√≠xeles y convirti√©ndolas a escala de grises.
- Visualiza 25 im√°genes del conjunto de datos de entrenamiento utilizando subplots.

### 6. **Preparaci√≥n de datos de entrenamiento**

```python
# Lista que contendr√° todas las im√°genes preprocesadas y sus etiquetas
datos_entrenamiento = []

# Procesar todas las im√°genes del conjunto de datos de entrenamiento
for i, (imagen, etiqueta) in enumerate(datos['train']):
    # Redimensionar la imagen a 100x100 p√≠xeles
    imagen = cv2.resize(imagen.numpy(), (TAMANO_IMG, TAMANO_IMG))
    # Convertir la imagen a escala de grises
    imagen = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    # A√±adir una dimensi√≥n para canales (necesario para modelos de TF)
    imagen = imagen.reshape(TAMANO_IMG, TAMANO_IMG, 1)
    # A√±adir la imagen y su etiqueta a la lista de datos de entrenamiento
    datos_entrenamiento.append([imagen, etiqueta])
```

Esta celda:

- Prepara los datos de entrenamiento redimensionando todas las im√°genes a 100x100 p√≠xeles, convirti√©ndolas a escala de grises y agreg√°ndoles una dimensi√≥n adicional.
- Almacena cada imagen preprocesada junto con su etiqueta correspondiente en una lista.


### 7. **Separaci√≥n de datos en entradas (X) y etiquetas (y)**

```python
# Preparar variables X (entradas) y y (etiquetas) separadas
X = []  # Lista para almacenar las im√°genes de entrada (p√≠xeles)
y = []  # Lista para almacenar las etiquetas (perro o gato)

# Separar las im√°genes y etiquetas del conjunto de datos de entrenamiento
for imagen, etiqueta in datos_entrenamiento:
    X.append(imagen)
    y.append(etiqueta)
```

Esta celda separa las im√°genes y las etiquetas en dos listas diferentes: `X` para las im√°genes y `y` para las etiquetas.

### 8. **Normalizaci√≥n de datos**

```python
# Importar numpy para manipulaci√≥n de arrays
import numpy as np

# Normalizar los datos de las im√°genes
# Convertir las listas a arrays de NumPy, convertir a flotantes y dividir por 255 para normalizar al rango 0-1
X = np.array(X).astype(float) / 255
```

Esta celda normaliza los datos de las im√°genes convirti√©ndolas a valores flotantes entre 0 y 1.

### 9. **Conversi√≥n de etiquetas a array**

```python
# Convertir etiquetas a un array de NumPy
y = np.array(y)
```

Esta celda convierte la lista de etiquetas en un array de NumPy.

### 10. **Creaci√≥n de modelos**

```python
# Crear modelos iniciales

# Modelo denso completamente conectado
modeloDenso = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(100, 100, 1)),  # Aplanar la imagen de entrada
    tf.keras.layers.Dense(150, activation='relu'),  # Capa densa con 150 neuronas y ReLU
    tf.keras.layers.Dense(150, activation='relu'),  # Capa densa con 150 neuronas y ReLU
    tf.keras.layers.Dense(1, activation='sigmoid')  # Capa de salida con sigmoid para clasificaci√≥n binaria
])

# Modelo de red neuronal convolucional (CNN)
modeloCNN = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 1)),  # Capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Capa de max pooling
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),  # Segunda capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Segunda capa de max pooling
    tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),  # Tercera capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Tercera capa de max pooling
    tf.keras.layers.Flatten(),  # Aplanar antes de las capas densas
    tf.keras.layers.Dense(100, activation='relu'),  # Capa densa con 100 neuronas y ReLU
    tf.keras.layers.Dense(1, activation='sigmoid')  # Capa de salida con sigmoid para clasificaci√≥n binaria
])

# Modelo CNN con dropout para regularizaci√≥n
modeloCNN2 = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 1)),  # Capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Capa de max pooling
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),  # Segunda capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Segunda capa de max pooling
    tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),  # Tercera capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Tercera capa de max pooling
    tf.keras.layers.Dropout(0.5),  # Capa de dropout para regularizaci√≥n
    tf.keras.layers.Flatten(),  # Aplanar antes de las capas densas
    tf.keras.layers.Dense(250, activation='relu'),  # Capa densa con 250 neuronas y ReLU
    tf.keras.layers.Dense(1, activation='sigmoid')  # Capa de salida con sigmoid para clasificaci√≥n binaria
])
```

Esta celda crea tres modelos diferentes: un modelo denso (completamente conectado) y dos modelos de red neuronal convolucional (CNN) con diferentes arquitecturas.

### 11. **Compilaci√≥n de modelos**

```python
# Compilar modelos usando binary_crossentropy para la clasificaci√≥n binaria
# Usar el optimizador 'adam' y m√©tricas de 'accuracy' para evaluar el rendimiento

modeloDenso.compile(optimizer='adam',
                    loss='binary_crossentropy',
                    metrics=['accuracy'])

modeloCNN.compile(optimizer='adam',
                  loss='binary_crossentropy',
                  metrics=['accuracy'])

modeloCNN2.compile(optimizer='adam',
                   loss='binary_crossentropy',
                   metrics=['accuracy'])
```

Esta celda compila los tres modelos, especificando el optimizador `adam`, la funci√≥n de p√©rdida `binary_crossentropy`, y las m√©tricas de precisi√≥n (`accuracy`).

### 12. **Entrenamiento del modelo denso con TensorBoard**

```python
# Importar TensorBoard para visualizaci√≥n de los resultados del entrenamiento
from tensorflow.keras.callbacks import TensorBoard

# Configurar TensorBoard para el modelo denso
tensorboardDenso = TensorBoard(log_dir='logs/denso')

# Entrenar el modelo denso
modeloDenso.fit(X, y, batch_size=32,  # Tama√±o del lote
                validation_split=0.15,  # Divisi√≥n del conjunto de datos para validaci√≥n
                epochs=100,  # N√∫mero de √©pocas de entrenamiento
                callbacks=[tensorboardDenso])  # Registrar el progreso con TensorBoard
```

Esta celda entrena el modelo denso usando TensorBoard para registrar y visualizar el progreso del entrenamiento.

Continuando con la explicaci√≥n mejorada y comentarios detallados:

### 13. **Carga de la extensi√≥n TensorBoard**

```python
# Cargar la extensi√≥n de TensorBoard de Colab para visualizar los resultados del entrenamiento
%load_ext tensorboard
```

Esta celda carga la extensi√≥n de TensorBoard en Colab, lo que permite visualizar los registros de entrenamiento directamente en el entorno de Colab.

### 14. **Ejecuci√≥n de TensorBoard**

```python
# Ejecutar TensorBoard e indicarle que lea la carpeta "logs"
%tensorboard --logdir logs
```

Esta celda inicia TensorBoard y le indica que lea los registros de la carpeta "logs", lo que permite monitorear el progreso del entrenamiento en tiempo real.

### 15. **Entrenamiento del modelo CNN con TensorBoard**

```python
# Configurar TensorBoard para el modelo CNN
tensorboardCNN = TensorBoard(log_dir='logs/cnn')

# Entrenar el modelo CNN
modeloCNN.fit(X, y, batch_size=32,  # Tama√±o del lote
              validation_split=0.15,  # Divisi√≥n del conjunto de datos para validaci√≥n
              epochs=100,  # N√∫mero de √©pocas de entrenamiento
              callbacks=[tensorboardCNN])  # Registrar el progreso con TensorBoard
```

Esta celda entrena el primer modelo CNN y utiliza TensorBoard para registrar el progreso del entrenamiento.

### 16. **Entrenamiento del modelo CNN2 con TensorBoard**

```python
# Configurar TensorBoard para el modelo CNN2
tensorboardCNN2 = TensorBoard(log_dir='logs/cnn2')

# Entrenar el modelo CNN2
modeloCNN2.fit(X, y, batch_size=32,  # Tama√±o del lote
               validation_split=0.15,  # Divisi√≥n del conjunto de datos para validaci√≥n
               epochs=100,  # N√∫mero de √©pocas de entrenamiento
               callbacks=[tensorboardCNN2])  # Registrar el progreso con TensorBoard
```

Esta celda entrena el segundo modelo CNN y utiliza TensorBoard para registrar el progreso del entrenamiento.

### 17. **Visualizaci√≥n de im√°genes sin aumento de datos**

```python
# Ver las im√°genes de la variable X sin modificaciones por aumento de datos
plt.figure(figsize=(20, 8))

# Visualizar las primeras 10 im√°genes del conjunto de datos sin modificaciones
for i in range(10):
    plt.subplot(2, 5, i + 1)
    plt.xticks([])  # Eliminar marcas del eje x
    plt.yticks([])  # Eliminar marcas del eje y
    plt.imshow(X[i].reshape(100, 100), cmap="gray")  # Mostrar la imagen en escala de grises
plt.show()
```

Esta celda visualiza 10 im√°genes del conjunto de datos sin aplicar aumento de datos, mostrando las im√°genes originales.

### 18. **Aumento de datos y visualizaci√≥n**

```python
# Importar ImageDataGenerator para realizar el aumento de datos
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Configurar el generador de datos con varias transformaciones
datagen = ImageDataGenerator(
    rotation_range=30,  # Rotar im√°genes hasta 30 grados
    width_shift_range=0.2,  # Desplazar im√°genes horizontalmente hasta un 20%
    height_shift_range=0.2,  # Desplazar im√°genes verticalmente hasta un 20%
    shear_range=15,  # Aplicar cizalladura a las im√°genes hasta 15 grados
    zoom_range=[0.7, 1.4],  # Aplicar zoom a las im√°genes entre 0.7x y 1.4x
    horizontal_flip=True,  # Permitir voltear horizontalmente las im√°genes
    vertical_flip=True  # Permitir voltear verticalmente las im√°genes
)

# Ajustar el generador a las im√°genes
datagen.fit(X)

# Visualizar ejemplos de im√°genes aumentadas
plt.figure(figsize=(20, 8))

# Generar y mostrar 10 im√°genes aumentadas
for imagen, etiqueta in datagen.flow(X, y, batch_size=10, shuffle=False):
    for i in range(10):
        plt.subplot(2, 5, i + 1)
        plt.xticks([])  # Eliminar marcas del eje x
        plt.yticks([])  # Eliminar marcas del eje y
        plt.imshow(imagen[i].reshape(100, 100), cmap="gray")  # Mostrar la imagen en escala de grises
    break  # Salir del bucle despu√©s de visualizar 10 im√°genes
plt.show()
```

Esta celda realiza el aumento de datos aplicando varias transformaciones a las im√°genes y luego visualiza 10 ejemplos de im√°genes aumentadas.

### 19. **Creaci√≥n de modelos con aumento de datos**

```python
# Crear nuevos modelos para entrenar con aumento de datos

# Modelo denso con aumento de datos
modeloDenso_AD = tf.keras.models.Sequential([
    tf.keras.layers.Flatten(input_shape=(100, 100, 1)),  # Aplanar la imagen de entrada
    tf.keras.layers.Dense(150, activation='relu'),  # Capa densa con 150 neuronas y ReLU
    tf.keras.layers.Dense(150, activation='relu'),  # Capa densa con 150 neuronas y ReLU
    tf.keras.layers.Dense(1, activation='sigmoid')  # Capa de salida con sigmoid para clasificaci√≥n binaria
])

# Modelo CNN con aumento de datos
modeloCNN_AD = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 1)),  # Capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Capa de max pooling
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),  # Segunda capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Segunda capa de max pooling
    tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),  # Tercera capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Tercera capa de max pooling
    tf.keras.layers.Flatten(),  # Aplanar antes de las capas densas
    tf.keras.layers.Dense(100, activation='relu'),  # Capa densa con 100 neuronas y ReLU
    tf.keras.layers.Dense(1, activation='sigmoid')  # Capa de salida con sigmoid para clasificaci√≥n binaria
])

# Modelo CNN con dropout y aumento de datos
modeloCNN2_AD = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 1)),  # Capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Capa de max pooling
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),  # Segunda capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Segunda capa de max pooling
    tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),  # Tercera capa convolucional
    tf.keras.layers.MaxPooling2D(2, 2),  # Tercera capa de max pooling
    tf.keras.layers.Dropout(0.5),  # Capa de dropout para regularizaci√≥n
    tf.keras.layers.Flatten(),  # Aplanar antes de las capas densas
    tf.keras.layers.Dense(250, activation='relu'),  # Capa densa con 250 neuronas y ReLU
    tf.keras.layers.Dense(1, activation='sigmoid')  # Capa de salida con sigmoid para clasificaci√≥n binaria
])
```

Esta celda crea nuevos modelos con las mismas estructuras que los anteriores, pero se utilizar√°n para entrenar con datos aumentados.

Continuando con la explicaci√≥n detallada y comentarios del c√≥digo:

### 20. **Compilaci√≥n de modelos con aumento de datos**

```python
# Compilar los nuevos modelos con datos aumentados
modeloDenso_AD.compile(optimizer='adam',
                       loss='binary_crossentropy',
                       metrics=['accuracy'])

modeloCNN_AD.compile(optimizer='adam',
                     loss='binary_crossentropy',
                     metrics=['accuracy'])

modeloCNN2_AD.compile(optimizer='adam',
                      loss='binary_crossentropy',
                      metrics=['accuracy'])
```

Esta celda compila los modelos `modeloDenso_AD`, `modeloCNN_AD` y `modeloCNN2_AD` para ser entrenados con datos aumentados. Se utiliza el optimizador Adam, la funci√≥n de p√©rdida `binary_crossentropy` adecuada para problemas de clasificaci√≥n binaria, y se eval√∫a la m√©trica de precisi√≥n (`accuracy`).

### 21. **Separaci√≥n de datos de entrenamiento y validaci√≥n**

```python
# Separar los datos en conjuntos de entrenamiento y validaci√≥n
split_index = int(len(X) * 0.85)

X_entrenamiento = X[:split_index]
X_validacion = X[split_index:]

y_entrenamiento = y[:split_index]
y_validacion = y[split_index:]
```

Esta celda divide los datos en conjuntos de entrenamiento (85%) y validaci√≥n (15%). `X_entrenamiento` y `y_entrenamiento` contienen los datos para entrenar los modelos, mientras que `X_validacion` y `y_validacion` se utilizan para validar el rendimiento de los modelos durante el entrenamiento.

### 22. **Creaci√≥n del generador de datos de entrenamiento**

```python
# Crear un generador de datos para aplicar aumento de datos en tiempo real durante el entrenamiento
data_gen_entrenamiento = datagen.flow(X_entrenamiento, y_entrenamiento, batch_size=32)
```

Esta celda crea un generador de datos utilizando `datagen.flow`, que aplica aumentos de datos en tiempo real durante el entrenamiento. `batch_size=32` especifica el tama√±o del lote utilizado para el entrenamiento.

### 23. **Entrenamiento del modelo denso con aumento de datos**

```python
tensorboardDenso_AD = TensorBoard(log_dir='logs/denso_AD')

modeloDenso_AD.fit(
    data_gen_entrenamiento,
    epochs=100,
    batch_size=32,
    validation_data=(X_validacion, y_validacion),
    steps_per_epoch=int(np.ceil(len(X_entrenamiento) / float(32))),
    validation_steps=int(np.ceil(len(X_validacion) / float(32))),
    callbacks=[tensorboardDenso_AD]
)
```

Esta celda entrena el modelo denso con datos aumentados. Se utiliza `data_gen_entrenamiento` como fuente de datos de entrenamiento, se especifica la validaci√≥n usando `X_validacion` y `y_validacion`, y se registran m√©tricas y registros de entrenamiento en TensorBoard con `TensorBoard`.

### 24. **Entrenamiento del modelo CNN con aumento de datos**

```python
tensorboardCNN_AD = TensorBoard(log_dir='logs-new/cnn_AD')

modeloCNN_AD.fit(
    data_gen_entrenamiento,
    epochs=150,
    batch_size=32,
    validation_data=(X_validacion, y_validacion),
    steps_per_epoch=int(np.ceil(len(X_entrenamiento) / float(32))),
    validation_steps=int(np.ceil(len(X_validacion) / float(32))),
    callbacks=[tensorboardCNN_AD]
)
```

Esta celda entrena el modelo CNN inicial con datos aumentados. Al igual que el modelo denso, se utiliza el generador de datos `data_gen_entrenamiento` para aplicar aumentos de datos en tiempo real durante el entrenamiento, se especifican las √©pocas (`epochs`) y el tama√±o del lote (`batch_size`), y se registran m√©tricas y registros de entrenamiento en TensorBoard.

### 25. **Entrenamiento del modelo CNN2 con aumento de datos**

```python
tensorboardCNN2_AD = TensorBoard(log_dir='logs/cnn2_AD')

modeloCNN2_AD.fit(
    data_gen_entrenamiento,
    epochs=100,
    batch_size=32,
    validation_data=(X_validacion, y_validacion),
    steps_per_epoch=int(np.ceil(len(X_entrenamiento) / float(32))),
    validation_steps=int(np.ceil(len(X_validacion) / float(32))),
    callbacks=[tensorboardCNN2_AD]
)
```

Esta celda entrena el segundo modelo CNN con datos aumentados. Se utiliza el mismo enfoque que los modelos anteriores para aplicar aumentos de datos y registrar m√©tricas en TensorBoard.


### Demo y video en youtube por el canal de youtube Ringa Tech

https://ringa-tech.com/exportacion/perros-gatos/index.html

https://youtu.be/DbwKbsCWPSg?si=_FiIy7Lt7w-yIS3R

### Recursos para Explorar M√°s:
- **[Redes neuronales convolucionales
](https://www.youtube.com/live/2cz1hEb52n4?si=Z6UTm834iX2htzHI)** Taller completo de 3 horas con proyecto de Redes neuronales convolucionales.

## Colab Notebooks


- [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1Efva3sau54WHusFRnfcFxL-9sLuO27L0) [D√≠a 26: Clasificador de perros y gatos](https://colab.research.google.com/drive/1Efva3sau54WHusFRnfcFxL-9sLuO27L0)

---

# D√≠a27
---
## Explorando arquitecturas influyentes en el aprendizaje profundo üß†üîç

¬°Hola a todos! En el d√≠a 27 de nuestro desaf√≠o #100DaysOfAI, vamos a explorar algunas de las arquitecturas m√°s influyentes y populares en el Deep Learning. Estas arquitecturas han definido el camino del aprendizaje profundo en la √∫ltima d√©cada, con aplicaciones que van desde la clasificaci√≥n de im√°genes hasta la detecci√≥n de objetos en tiempo real. ¬°Vamos a descubrirlas!

| **Arquitectura** | **A√±o** | **Caracter√≠sticas Principales** | **Ventajas** | **Desventajas** | **Paper** |
|------------------|---------|-----------------------------|--------------|-----------------|-----------|
| **LeNet** | 1998 | Capas convolucionales y submuestreo | Pionera en el uso de CNNs para la clasificaci√≥n de d√≠gitos manuscritos | Muy simple y no adecuada para tareas modernas complejas | [LeNet Paper](http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf) |
| **AlexNet** | 2012 | 5 capas convolucionales, 3 fully connected | Pionera en CNNs profundas, gan√≥ ImageNet 2012 | Relativamente simple comparada con modelos modernos | [AlexNet Paper](https://papers.nips.cc/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf) |
| **VGGNet** | 2014 | Capas 3x3 apiladas, profundidad aumentada | Simplicidad, buena transferencia de aprendizaje | Muchos par√°metros, computacionalmente costosa | [VGGNet Paper](https://arxiv.org/pdf/1409.1556.pdf) |
| **Inception (GoogLeNet)** | 2014 | M√≥dulos Inception, 1x1 convolutions | Eficiente en par√°metros, buena escala | Compleja de implementar | [Inception Paper](https://arxiv.org/pdf/1409.4842.pdf) |
| **R-CNN (y variantes)** | 2014-2015 | Regiones de inter√©s, fine-tuning | Precisi√≥n en detecci√≥n de objetos | Lenta (original), versiones posteriores m√°s r√°pidas | [R-CNN Paper](https://arxiv.org/pdf/1311.2524.pdf) |
| **Faster R-CNN** | 2015 | Regiones de inter√©s generadas por una red, detecci√≥n r√°pida | Mejor equilibrio entre velocidad y precisi√≥n | M√°s compleja de implementar y entrenar | [Faster R-CNN Paper](https://arxiv.org/pdf/1506.01497.pdf) |
| **ResNet** | 2015 | Conexiones residuales (skip connections) | Muy profunda (hasta 152 capas), resuelve desvanecimiento del gradiente | Puede ser overkill para tareas simples | [ResNet Paper](https://arxiv.org/pdf/1512.03385.pdf) |
| **U-Net** | 2015 | Arquitectura en forma de U, skip connections | Excelente para segmentaci√≥n de im√°genes m√©dicas | Puede ser excesiva para tareas de clasificaci√≥n simples | [U-Net Paper](https://arxiv.org/pdf/1505.04597.pdf) |
| **SqueezeNet** | 2016 | M√≥dulos Fire, convoluciones 1x1 | Muy compacta, pocos par√°metros | Precisi√≥n algo menor que modelos m√°s grandes | [SqueezeNet Paper](https://arxiv.org/pdf/1602.07360.pdf) |
| **YOLO** | 2016 | Detecci√≥n en tiempo real, una sola red convolucional | R√°pida y precisa en la detecci√≥n de objetos | Menor precisi√≥n en comparaci√≥n con m√©todos m√°s lentos | [YOLO Paper](https://arxiv.org/pdf/1506.02640.pdf) |
| **DenseNet** | 2017 | Conexiones densas entre capas | Uso eficiente de par√°metros, fuerte propagaci√≥n de caracter√≠sticas | Alto consumo de memoria | [DenseNet Paper](https://arxiv.org/pdf/1608.06993.pdf) |
| **MobileNet** | 2017 | Convoluciones separables en profundidad | Eficiente para dispositivos m√≥viles | Precisi√≥n ligeramente menor que modelos m√°s grandes | [MobileNet Paper](https://arxiv.org/pdf/1704.04861.pdf) |
| **Xception** | 2017 | Convoluciones separables en profundidad extremas | Eficiente en par√°metros, buena precisi√≥n | Puede ser compleja de implementar | [Xception Paper](https://arxiv.org/pdf/1610.02357.pdf) |
| **ShuffleNet** | 2017 | Group convolutions, channel shuffle | Muy eficiente para dispositivos m√≥viles | Posible p√©rdida de precisi√≥n en tareas complejas | [ShuffleNet Paper](https://arxiv.org/pdf/1707.01083.pdf) |
| **NASNet** | 2018 | Arquitectura encontrada por b√∫squeda neural | Altamente optimizada | Compleja, costosa de entrenar | [NASNet Paper](https://arxiv.org/pdf/1707.07012.pdf) |
| **SENet** | 2017 | M√≥dulos Squeeze-and-Excitation | Mejora la calidad de las representaciones | Ligero aumento en costo computacional | [SENet Paper](https://arxiv.org/pdf/1709.01507.pdf) |
| **FPN** | 2017 | Pir√°mide de caracter√≠sticas multi-escala | Excelente para detecci√≥n de objetos | Puede ser excesiva para tareas de clasificaci√≥n simples | [FPN Paper](https://arxiv.org/pdf/1612.03144.pdf) |
| **EfficientNet** | 2019 | Escalado compuesto de profundidad/anchura/resoluci√≥n | Muy eficiente, estado del arte en precisi√≥n/eficiencia | Compleja de implementar y ajustar | [EfficientNet Paper](https://arxiv.org/pdf/1905.11946.pdf) |
| **Vision Transformers (ViT)** | 2020 | Uso de transformadores en tareas de visi√≥n por computadora | Alta precisi√≥n en tareas de clasificaci√≥n de im√°genes | Requiere una gran cantidad de datos para entrenar eficazmente | [ViT Paper](https://arxiv.org/pdf/2010.11929.pdf) |

Estas arquitecturas han desempe√±ado un papel fundamental en la evoluci√≥n de la visi√≥n por computadora y el Deep Learning. Cada una tiene sus propias ventajas y desventajas, pero todas han contribuido de manera significativa al avance de la tecnolog√≠a.

---

# D√≠a28
---


## Arquitecturas Espec√≠ficas en Visi√≥n por Computadora üéØüñ•Ô∏è

Continuando con nuestro viaje por las arquitecturas de redes neuronales, hoy exploramos c√≥mo diferentes arquitecturas destacan en tareas espec√≠ficas dentro de la visi√≥n por computadora:

1. **Clasificaci√≥n a gran escala: EfficientNet üèÜ**
   - **Equilibrio √≥ptimo:** Combina profundidad, anchura y resoluci√≥n de manera eficiente.
   - **Precisi√≥n alta con menos par√°metros:** Logra resultados superiores con una menor cantidad de par√°metros.

2. **Detecci√≥n en tiempo real: YOLO üèÉ‚Äç‚ôÇÔ∏è**
   - **Enfoque de una sola pasada:** Permite una detecci√≥n r√°pida y eficiente.
   - **Ideal para aplicaciones como conducci√≥n aut√≥noma:** Su velocidad lo hace perfecto para escenarios que requieren respuestas inmediatas.

3. **Segmentaci√≥n m√©dica: U-Net üè•**
   - **Arquitectura en U con conexiones de salto (skip connections):** Mejora la precisi√≥n en la segmentaci√≥n.
   - **Excelente con datos limitados en im√°genes biom√©dicas:** Ideal para aplicaciones m√©dicas donde los datos son escasos.

4. **Dispositivos m√≥viles: MobileNet üì±**
   - **Convoluciones separables en profundidad:** Reduce la carga computacional manteniendo un buen rendimiento.
   - **Eficiente en recursos limitados:** Dise√±ado para funcionar bien en dispositivos con capacidades limitadas.

5. **Visi√≥n de alto nivel: Vision Transformers (ViT) üëÅÔ∏è**
   - **Adaptaci√≥n de transformadores a visi√≥n:** Utiliza la atenci√≥n a escala completa para procesar im√°genes.
   - **Rendimiento superior con grandes conjuntos de datos:** Necesita grandes vol√∫menes de datos para entrenarse adecuadamente.

6. **Transferencia de aprendizaje: ResNet üîÑ**
   - **Conexiones residuales:** Facilitan el entrenamiento de redes muy profundas.
   - **Excelente extractor de caracter√≠sticas generales:** Muy √∫til en diversas tareas de visi√≥n por computadora.

Cada arquitectura brilla en su dominio, demostrando la diversidad y especializaci√≥n en el campo de la visi√≥n por computadora. La elecci√≥n correcta puede marcar la diferencia en el √©xito de un proyecto de IA. üåü

### Recursos Adicionales

- **EfficientNet:** [Estudio comparativo en ImageNet](https://arxiv.org/abs/1905.11946)
- **YOLO:** [Caso de √©xito en conducci√≥n aut√≥noma](https://pjreddie.com/darknet/yolo/)
- **U-Net:** [Aplicaci√≥n en im√°genes biom√©dicas](https://arxiv.org/abs/1505.04597)
- **MobileNet:** [Evaluaci√≥n en dispositivos m√≥viles](https://arxiv.org/abs/1704.04861)
- **Vision Transformers (ViT):** [Adaptaci√≥n de transformadores a visi√≥n](https://arxiv.org/abs/2010.11929)
- **ResNet:** [Desempe√±o en diversas tareas](https://arxiv.org/abs/1512.03385)

---

# D√≠a29
---
## Concepto de Transfer Learning üöÄüß†

¬°Hola a todos! En el d√≠a 29 de nuestro desaf√≠o #100DaysOfAI, vamos a explorar el fascinante concepto de **Transfer Learning**. Esta t√©cnica ha revolucionado la forma en que abordamos problemas de aprendizaje profundo, especialmente cuando tenemos datos limitados. ¬°Vamos a sumergirnos en los detalles!


#### ¬øQu√© es el Transfer Learning?

El **Transfer Learning** es una t√©cnica en la que un modelo preentrenado en una tarea (generalmente en un conjunto de datos grande y gen√©rico) se reutiliza y ajusta para una tarea diferente, generalmente con un conjunto de datos m√°s peque√±o y espec√≠fico. En lugar de entrenar un modelo desde cero, lo que puede ser costoso en t√©rminos de tiempo y recursos computacionales, utilizamos el conocimiento ya adquirido por el modelo preentrenado.


#### Ventajas del Transfer Learning

1. **Ahorro de Tiempo y Recursos**: Dado que el modelo ya ha aprendido caracter√≠sticas b√°sicas de datos similares, el tiempo de entrenamiento se reduce significativamente.
2. **Mejor Rendimiento**: Los modelos preentrenados suelen proporcionar una mejor precisi√≥n en tareas espec√≠ficas, especialmente cuando los datos disponibles son limitados.
3. **Facilidad de Implementaci√≥n**: Muchas bibliotecas de Deep Learning, como TensorFlow y PyTorch, proporcionan modelos preentrenados que se pueden utilizar f√°cilmente.


#### ¬øC√≥mo Funciona el Transfer Learning?

El Transfer Learning generalmente implica los siguientes pasos:

1. **Seleccionar un Modelo Preentrenado**: Elegimos un modelo que ha sido entrenado en una tarea similar, como la clasificaci√≥n de im√°genes en el conjunto de datos ImageNet.
2. **Ajuste del Modelo (Fine-Tuning)**: Modificamos las √∫ltimas capas del modelo para que se adapten a nuestra tarea espec√≠fica. Por ejemplo, en lugar de clasificar 1000 categor√≠as de ImageNet, podr√≠amos clasificar solo 10 categor√≠as espec√≠ficas de nuestro problema.
3. **Entrenamiento en Datos Espec√≠ficos**: Entrenamos el modelo ajustado en nuestro conjunto de datos espec√≠fico. Este entrenamiento suele ser m√°s r√°pido y requiere menos datos que entrenar un modelo desde cero.


#### Aplicaciones del Transfer Learning

El Transfer Learning se ha utilizado con √©xito en diversas √°reas, como:

- **Clasificaci√≥n de Im√°genes**: Uso de modelos preentrenados como ResNet, Inception o VGG para tareas de clasificaci√≥n de im√°genes espec√≠ficas.
- **Detecci√≥n de Objetos**: Modelos como YOLO o Faster R-CNN se ajustan para detectar objetos en nuevos conjuntos de datos.
- **Procesamiento del Lenguaje Natural (NLP)**: Modelos como BERT, GPT-3 y otros se utilizan para tareas de clasificaci√≥n de texto, an√°lisis de sentimientos y m√°s.
- **Reconocimiento de Voz**: Uso de modelos preentrenados para transcribir y comprender el habla en diferentes idiomas y acentos.


#### Ejemplo Pr√°ctico en Python (con TensorFlow/Keras)

```python
import tensorflow as tf
from tensorflow.keras.applications import VGG16
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.models import Model

# Cargar el modelo VGG16 preentrenado sin la √∫ltima capa
base_model = VGG16(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Congelar las capas del modelo base
for layer in base_model.layers:
    layer.trainable = False

# A√±adir nuevas capas personalizadas
x = base_model.output
x = Flatten()(x)
x = Dense(1024, activation='relu')(x)
predictions = Dense(10, activation='softmax')(x)  # Asumiendo 10 clases en el nuevo conjunto de datos

# Crear el modelo final
model = Model(inputs=base_model.input, outputs=predictions)

# Compilar el modelo
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Preparar los datos
train_datagen = ImageDataGenerator(rescale=1.0/255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True)
train_generator = train_datagen.flow_from_directory('path/to/train_data', target_size=(224, 224), batch_size=32, class_mode='categorical')

# Entrenar el modelo
model.fit(train_generator, epochs=10, steps_per_epoch=100)
```

---

El Transfer Learning es una herramienta poderosa en el arsenal del Deep Learning, permitiendo aprovechar modelos robustos y aplicarlos a nuevas tareas con eficiencia y precisi√≥n.

# D√≠a30
---
###  T√©cnicas de Transfer Learning üìöüöÄ

¬°Hola a todos! En el d√≠a 30 de nuestro desaf√≠o #100DaysOfAI, vamos a profundizar en las **t√©cnicas de Transfer Learning** y c√≥mo utilizar modelos preentrenados para abordar nuevas tareas. Esta metodolog√≠a permite ahorrar tiempo y mejorar el rendimiento en tareas espec√≠ficas. ¬°Vamos a explorar c√≥mo hacerlo!


#### T√©cnicas de Transfer Learning

1. **Feature Extraction (Extracci√≥n de Caracter√≠sticas)**

   En esta t√©cnica, utilizamos un modelo preentrenado como extractor de caracter√≠sticas. Las capas convolucionales de un modelo, por ejemplo, ResNet o VGG, act√∫an como un filtro que extrae caracter√≠sticas relevantes de las im√°genes. Luego, agregamos y entrenamos capas adicionales para la tarea espec√≠fica que queremos abordar.

   **Pasos:**
   - Cargar un modelo preentrenado sin la √∫ltima capa de clasificaci√≥n.
   - Congelar las capas del modelo base.
   - A√±adir nuevas capas personalizadas para la tarea espec√≠fica.
   - Entrenar solo las nuevas capas.

   ```python
   from tensorflow.keras.applications import VGG16
   from tensorflow.keras.models import Model
   from tensorflow.keras.layers import Dense, Flatten

   # Cargar el modelo VGG16 preentrenado sin la √∫ltima capa
   base_model = VGG16(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

   # Congelar las capas del modelo base
   for layer in base_model.layers:
       layer.trainable = False

   # A√±adir nuevas capas personalizadas
   x = base_model.output
   x = Flatten()(x)
   x = Dense(1024, activation='relu')(x)
   predictions = Dense(10, activation='softmax')(x)  # Asumiendo 10 clases en el nuevo conjunto de datos

   # Crear el modelo final
   model = Model(inputs=base_model.input, outputs=predictions)

   # Compilar el modelo
   model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
   ```

2. **Fine-Tuning (Ajuste Fino)**

   El ajuste fino implica descongelar algunas de las capas superiores del modelo base y entrenarlas junto con las nuevas capas a√±adidas. Esto permite que el modelo ajuste las caracter√≠sticas preentrenadas a la tarea espec√≠fica de manera m√°s precisa.

   **Pasos:**
   - Cargar un modelo preentrenado sin la √∫ltima capa de clasificaci√≥n.
   - Congelar la mayor√≠a de las capas del modelo base, pero dejar algunas capas superiores entrenables.
   - A√±adir nuevas capas personalizadas para la tarea espec√≠fica.
   - Entrenar tanto las nuevas capas como las capas superiores descongeladas del modelo base.

   ```python
   # Descongelar algunas capas del modelo base para el fine-tuning
   for layer in base_model.layers[-4:]:
       layer.trainable = True

   # Recompilar el modelo
   model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

   # Entrenar el modelo
   model.fit(train_generator, epochs=10, steps_per_epoch=100)
   ```

   Consejos adicionales para Fine-Tuning:
   - Utiliza una tasa de aprendizaje m√°s baja para evitar destruir el conocimiento preentrenado.
   - Considera el uso de "discriminative fine-tuning", donde diferentes capas tienen diferentes tasas de aprendizaje.
   - Monitorea el rendimiento en un conjunto de validaci√≥n para evitar el sobreajuste.

3. **Gradual Unfreezing**
   Esta t√©cnica es una extensi√≥n del fine-tuning donde descongelamos gradualmente m√°s capas del modelo base a medida que avanza el entrenamiento.

   **Pasos:**
   - Comenzar con todas las capas del modelo base congeladas, excepto la √∫ltima.
   - Entrenar por algunas √©pocas.
   - Descongelar la siguiente capa y continuar el entrenamiento.
   - Repetir hasta alcanzar el rendimiento deseado o hasta descongelar todas las capas.

```python
def unfreeze_model(model):
    for layer in model.layers:
        layer.trainable = True
    return model

epochs_per_stage = 5
total_stages = len(base_model.layers) // 3

for i in range(total_stages):
    if i > 0:
        base_model.layers[-3*i:] = unfreeze_model(base_model.layers[-3*i:])
    
    model.compile(optimizer=tf.keras.optimizers.Adam(1e-5*(0.9**i)),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])
    
    model.fit(train_generator, epochs=epochs_per_stage, validation_data=val_generator)
```

4. **Domain Adaptation**
   Esta t√©cnica se utiliza cuando el dominio de los datos de entrenamiento (fuente) es diferente al dominio de los datos de prueba (objetivo).

   **Idea principal:**
   - Entrenar un modelo que pueda extraer caracter√≠sticas que sean invariantes entre los dominios fuente y objetivo.
   - Utilizar t√©cnicas como Adversarial Domain Adaptation para alinear las distribuciones de caracter√≠sticas.

```python
from tensorflow.keras.layers import Input, Dense, Lambda
from tensorflow.keras.models import Model
import tensorflow.keras.backend as K

def build_domain_adaptation_model(base_model, num_classes):
    input = Input(shape=(224, 224, 3))
    features = base_model(input)
    class_output = Dense(num_classes, activation='softmax', name='class_output')(features)
    
    # Domain classifier
    domain_output = Dense(1, activation='sigmoid', name='domain_output')(Lambda(lambda x: K.reverse(x, axes=1))(features))
    
    model = Model(inputs=input, outputs=[class_output, domain_output])
    return model

domain_model = build_domain_adaptation_model(base_model, num_classes=10)
domain_model.compile(optimizer='adam',
                     loss={'class_output': 'categorical_crossentropy',
                           'domain_output': 'binary_crossentropy'},
                     loss_weights={'class_output': 1., 'domain_output': 0.1},
                     metrics={'class_output': 'accuracy', 'domain_output': 'accuracy'})
```

5. **Few-shot Learning**
   Esta t√©cnica se utiliza cuando solo tenemos unos pocos ejemplos de las nuevas clases que queremos clasificar.

   **Enfoques comunes:**
   - Prototypical Networks: Aprenden un espacio de embedding donde los puntos de la misma clase se agrupan alrededor de un "prototipo".
   - Matching Networks: Utilizan atenci√≥n para comparar nuevas muestras con un conjunto de soporte etiquetado.

La elecci√≥n de la t√©cnica de Transfer Learning depender√° de la naturaleza de tu tarea, la cantidad de datos disponibles y la similitud entre el dominio fuente y el objetivo. Experimenta con diferentes enfoques para encontrar el que mejor se adapte a tu problema espec√≠fico.




### Recursos Adicionales

1. **[Transfer Learning Guide by TensorFlow](https://www.tensorflow.org/tutorials/images/transfer_learning)**
2. **[PyTorch Transfer Learning Tutorial](https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html)**

---
# D√≠a31
---
## Detecci√≥n de Objetos üïµÔ∏è‚Äç‚ôÇÔ∏èüîç

#### ¬øQu√© es la Detecci√≥n de Objetos?

La detecci√≥n de objetos es una t√©cnica que permite a los modelos de visi√≥n por computadora identificar y localizar m√∫ltiples objetos dentro de una imagen. A diferencia de la clasificaci√≥n de im√°genes, donde el objetivo es identificar la clase principal de una imagen, la detecci√≥n de objetos busca encontrar todas las instancias de objetos de inter√©s y sus ubicaciones espec√≠ficas.


#### Conceptos B√°sicos de la Detecci√≥n de Objetos

1. **Bounding Box (Caja Delimitadora)**

   La detecci√≥n de objetos generalmente implica la predicci√≥n de una caja delimitadora para cada objeto en la imagen. Una caja delimitadora est√° definida por sus coordenadas (x, y) del v√©rtice superior izquierdo, as√≠ como su ancho y alto.

   

2. **Clasificaci√≥n de Objetos**

   Adem√°s de localizar un objeto, el modelo tambi√©n necesita clasificar qu√© tipo de objeto est√° presente dentro de cada caja delimitadora.

3. **Intersecci√≥n sobre Uni√≥n (IoU)**

   IoU es una m√©trica utilizada para evaluar la precisi√≥n de la predicci√≥n de la caja delimitadora. Se calcula como el √°rea de superposici√≥n entre la caja predicha y la caja real dividida por el √°rea de uni√≥n de ambas cajas.

  

4. **Modelos Comunes de Detecci√≥n de Objetos**

  - **R-CNN (Region-Based Convolutional Neural Networks)**: Propone regiones de inter√©s y aplica CNNs a cada regi√≥n.
   - **Fast R-CNN**: Optimiza R-CNN utilizando la detecci√≥n de regiones propuestas y CNNs en una sola pasada.
   - **Faster R-CNN**: Introduce una red separada para proponer regiones de inter√©s, lo que mejora la velocidad.
   - **YOLO (You Only Look Once)**: Predice las cajas delimitadoras y las clases de objetos en una sola pasada de la red, lo que lo hace muy r√°pido.
   - **SSD (Single Shot Multibox Detector)**: Similar a YOLO, realiza detecci√≥n en una sola pasada, pero con m√∫ltiples cajas de diferentes tama√±os.

---

### Ejemplo Pr√°ctico: Implementando YOLO para Detecci√≥n de Objetos

A continuaci√≥n, se muestra un ejemplo de c√≥mo implementar el modelo YOLO utilizando la librer√≠a `opencv` y un modelo preentrenado.

**Paso 1: Instalaci√≥n de Dependencias**
```python
!pip install opencv-python-headless
!pip install numpy
!pip install matplotlib

!wget https://pjreddie.com/media/files/yolov3.weights
!wget https://raw.githubusercontent.com/pjreddie/darknet/master/cfg/yolov3.cfg
!wget https://raw.githubusercontent.com/pjreddie/darknet/master/data/coco.names

```

**Paso 2: Cargar el Modelo YOLO Preentrenado y Realizar la Detecci√≥n**
```python

# Paso 3: Importar las bibliotecas necesarias
import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
import urllib.request

# Paso 4: Cargar el modelo YOLO preentrenado y los archivos de configuraci√≥n
net = cv2.dnn.readNet("yolov3.weights", "yolov3.cfg")
with open("coco.names", "r") as f:
    classes = [line.strip() for line in f.readlines()]
layer_names = net.getLayerNames()
output_layers = [layer_names[i - 1] for i in net.getUnconnectedOutLayers()]

# Funci√≥n para descargar una imagen de ejemplo
def download_image(url, filename):
    urllib.request.urlretrieve(url, filename)

# Descargar una imagen de ejemplo
image_url = "https://raw.githubusercontent.com/pjreddie/darknet/master/data/dog.jpg"
image_filename = "example_image.jpg"
download_image(image_url, image_filename)

# Paso 5: Cargar y preprocesar la imagen
image = cv2.imread(image_filename)
height, width, channels = image.shape
blob = cv2.dnn.blobFromImage(image, 0.00392, (416, 416), (0, 0, 0), True, crop=False)

# Paso 6: Realizar la detecci√≥n de objetos
net.setInput(blob)
outs = net.forward(output_layers)

# Paso 7: Procesar los resultados
class_ids = []
confidences = []
boxes = []
for out in outs:
    for detection in out:
        scores = detection[5:]
        class_id = np.argmax(scores)
        confidence = scores[class_id]
        if confidence > 0.5:
            # Obtener las coordenadas de la caja delimitadora
            center_x = int(detection[0] * width)
            center_y = int(detection[1] * height)
            w = int(detection[2] * width)
            h = int(detection[3] * height)
            # Coordenadas de la caja delimitadora
            x = int(center_x - w / 2)
            y = int(center_y - h / 2)
            boxes.append([x, y, w, h])
            confidences.append(float(confidence))
            class_ids.append(class_id)

# Paso 8: Aplicar Non-Maximum Suppression (NMS)
indexes = cv2.dnn.NMSBoxes(boxes, confidences, 0.5, 0.4)

# Paso 9: Dibujar las cajas delimitadoras y etiquetas
colors = np.random.uniform(0, 255, size=(len(classes), 3))
for i in range(len(boxes)):
    if i in indexes:
        x, y, w, h = boxes[i]
        label = str(classes[class_ids[i]])
        color = colors[class_ids[i]]
        cv2.rectangle(image, (x, y), (x + w, y + h), color, 2)
        cv2.putText(image, f"{label} {confidences[i]:.2f}", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

# Paso 10: Mostrar la imagen resultante
plt.figure(figsize=(12, 8))
plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
plt.axis('off')
plt.show()

print("Detecci√≥n de objetos completada.")
```

---

### Recursos Adicionales

1. **[YOLO: You Only Look Once (arXiv)](https://arxiv.org/pdf/1506.02640.pdf)**
2. **[SSD: Single Shot MultiBox Detector (arXiv)](https://arxiv.org/pdf/1512.02325.pdf)**
3. **[Faster R-CNN: Towards Real-Time Object Detection (arXiv)](https://arxiv.org/pdf/1506.01497.pdf)**
4. **[Detecting Objects in Images Using OpenCV YOLO](https://www.learnopencv.com/object-detection-using-yolo/)**

---

La detecci√≥n de objetos es una t√©cnica poderosa y vers√°til con muchas aplicaciones pr√°cticas. ¬°Espero que esta introducci√≥n les haya resultado √∫til y emocionante!



---
# D√≠a32
---
### Evoluci√≥n de YOLO: Desde 2015 hasta 2024

La serie de modelos YOLO (You Only Look Once) ha visto una evoluci√≥n significativa desde su creaci√≥n en 2015. Aqu√≠ se presenta un resumen de las principales versiones y sus mejoras a lo largo del tiempo:

1. **YOLO (2015)**
   - Introdujo el concepto de detecci√≥n de objetos en tiempo real utilizando una sola red convolucional.
   - Ventaja: Alta velocidad de inferencia.
   - Desventaja: Menor precisi√≥n en comparaci√≥n con otros m√©todos existentes en ese momento.

2. **YOLO9000 (2016)**
   - Capaz de detectar m√°s de 9000 clases de objetos mediante la combinaci√≥n de detecci√≥n y clasificaci√≥n jer√°rquica.
   - Mejora en precisi√≥n y capacidad de detecci√≥n de m√∫ltiples clases.

3. **YOLOv2 (2017)**
   - Introdujo mejoras como anclas dimensionadas y normalizaci√≥n por lotes.
   - Aument√≥ la precisi√≥n y la velocidad en comparaci√≥n con YOLO9000.

4. **Fast YOLO (2017)**
   - Optimizaci√≥n adicional para aumentar la velocidad de inferencia sin sacrificar demasiada precisi√≥n.

5. **YOLOv3 (2018)**
   - Implement√≥ una arquitectura m√°s profunda con ResNet, mejorando la precisi√≥n en detecci√≥n de objetos peque√±os.
   - Introducci√≥n de detecci√≥n en m√∫ltiples escalas.

6. **YOLOv4 (Abril de 2020)**
   - Incorpor√≥ varias t√©cnicas de mejora de precisi√≥n como CSPDarknet53, MISH, y regularizaci√≥n por recorte.
   - Mejoras significativas en velocidad y precisi√≥n.

7. **YOLOv5 (2020)**
   - Desarrollo por Ultralytics con optimizaciones adicionales en el entrenamiento y la inferencia.
   - Aumento de la flexibilidad y la facilidad de uso.

8. **YOLOR (2021)**
   - Introducci√≥n de conocimientos representacionales y operacionales unificados para mejorar la precisi√≥n.
   - Capacidad de realizar m√∫ltiples tareas simult√°neamente.

9. **YOLOv6 (2022)**
   - Mejoras en la arquitectura para una mayor eficiencia y rendimiento en dispositivos de baja potencia.

10. **YOLOv7 (2022)**
    - Introducci√≥n de t√©cnicas avanzadas para reducir la latencia y mejorar la precisi√≥n en tiempo real.

11. **YOLOv8 (2023)**
    - Mejora en la detecci√≥n de objetos peque√±os y en situaciones de baja iluminaci√≥n.
    - Incorporaci√≥n de m√≥dulos de atenci√≥n para mejor rendimiento.

12. **YOLOv9 (2024)**
    - Primer modelo inducido por transformador, utilizando GELAN (Red de Agregaci√≥n de Capas Eficientes Generalizadas) y PGI (Informaci√≥n de Gradiente Programable).
    - Mejora en la eficiencia computacional y reducci√≥n de par√°metros sin sacrificar precisi√≥n.

13. **YOLOv10 (2024)**
    - Introducci√≥n de entrenamiento sin NMS (Supresi√≥n No M√°xima), lo que reduce la dependencia de la post-procesamiento y mejora la velocidad de inferencia.
    - Empleo de asignaciones duales consistentes para mayor eficiencia y precisi√≥n.

Estas mejoras han permitido que YOLO mantenga su posici√≥n como una de las arquitecturas de detecci√≥n de objetos m√°s r√°pidas y precisas, adapt√°ndose continuamente a las necesidades y desaf√≠os de las aplicaciones modernas de visi√≥n por computadora.

Referencias:
- [YOLOv9: El primer modelo inducido por transformador](https://visionplatform.ai/es/yolov9-el-primer-modelo-inducido-por-transformador/)
- [YOLOv10: Mejor, m√°s r√°pido y m√°s peque√±o ahora en GitHub](https://docs.ultralytics.com/es/models/yolov10/#what-are-the-performance-benchmarks-for-yolov10-models)
- [YOLOv9 Performance Comparisons](https://arxiv.org/pdf/2405.14458v1)

---

# D√≠a33
---
## YOLOv8 y sus Variantes con Ultralytics

En el d√≠a de hoy, vamos a profundizar en YOLOv8 y sus variantes, as√≠ como en la suite de herramientas ofrecidas por Ultralytics que estaremos utilizando en nuestros proyectos de detecci√≥n de objetos. ¬°Vamos a ello!

#### üöÄ Introducci√≥n a YOLOv8

YOLO (You Only Look Once) ha sido una referencia en la detecci√≥n de objetos desde su primera versi√≥n lanzada en 2015. YOLOv8, desarrollado por Ultralytics, es la √∫ltima iteraci√≥n de esta serie, trayendo mejoras significativas en precisi√≥n, velocidad y eficiencia.

**Caracter√≠sticas de YOLOv8:**
- **Alta Precisi√≥n:** Mejoras en la arquitectura que permiten detectar objetos con mayor exactitud.
- **Velocidad de Inferencia:** Optimizado para realizar detecciones en tiempo real.
- **Eficiencia Computacional:** Reduce la carga computacional manteniendo un rendimiento superior.

#### üõ†Ô∏è Ultralytics y su Ecosistema

Ultralytics no solo ha desarrollado YOLOv8, sino que tambi√©n ha creado un conjunto de herramientas y recursos para facilitar su implementaci√≥n y uso en diversos proyectos de visi√≥n por computadora.

**Principales Componentes:**
- **YOLOv8 Modelos:** Variantes optimizadas para diferentes necesidades, como precisi√≥n m√°xima (YOLOv8x) y eficiencia (YOLOv8n).
- **Ultralytics Hub:** Plataforma centralizada para gestionar, entrenar y desplegar modelos de YOLO.
- **Documentaci√≥n y Soporte:** Gu√≠as detalladas, ejemplos y una comunidad activa para ayudar a los desarrolladores.

#### üß© Variantes de YOLOv8

Ultralytics ha lanzado varias variantes de YOLOv8, cada una ajustada para diferentes escenarios de uso:

1. **YOLOv8n (Nano):**
   - **Caracter√≠sticas:** Optimizado para dispositivos con recursos limitados, como m√≥viles.
   - **Ventajas:** Alta eficiencia y bajo consumo de recursos.

2. **YOLOv8s (Small):**
   - **Caracter√≠sticas:** Equilibrio entre precisi√≥n y velocidad.
   - **Ventajas:** Ideal para aplicaciones en tiempo real en dispositivos moderadamente potentes.

3. **YOLOv8m (Medium):**
   - **Caracter√≠sticas:** Mayor precisi√≥n con un compromiso razonable en velocidad.
   - **Ventajas:** Uso en aplicaciones que requieren un balance entre rendimiento y precisi√≥n.

4. **YOLOv8l (Large):**
   - **Caracter√≠sticas:** Alta precisi√≥n para tareas m√°s exigentes.
   - **Ventajas:** Uso en sistemas con capacidad computacional alta.

5. **YOLOv8x (Extra Large):**
   - **Caracter√≠sticas:** M√°xima precisi√≥n disponible en la serie YOLOv8.
   - **Ventajas:** Ideal para aplicaciones donde la precisi√≥n es cr√≠tica.

#### üîó Recursos de Ultralytics

- [Ultralytics GitHub](https://github.com/ultralytics): Repositorio oficial con c√≥digo fuente y ejemplos.
- [Documentaci√≥n de YOLOv8](https://docs.ultralytics.com/yolov8): Gu√≠a completa de uso y configuraci√≥n.
- [Ultralytics Hub](https://ultralytics.com/hub): Plataforma para gestionar y desplegar modelos.

---
# D√≠a34
---
### Aplicaciones Avanzadas de Detecci√≥n de Objetos üåçüöÄ**


#### üìå Aplicaciones en Seguridad
La detecci√≥n de objetos se utiliza en sistemas de videovigilancia para identificar intrusos, detectar comportamientos an√≥malos y alertar a las autoridades en tiempo real. Las soluciones basadas en IA pueden analizar grandes vol√∫menes de datos de video con precisi√≥n y rapidez, mejorando la seguridad en √°reas p√∫blicas y privadas.

#### üìä Aplicaciones en el Sector Salud
En el campo de la salud, la detecci√≥n de objetos ayuda en el an√°lisis de im√°genes m√©dicas, como radiograf√≠as y resonancias magn√©ticas. Esto permite a los m√©dicos identificar anomal√≠as, diagnosticar enfermedades y planificar tratamientos con mayor precisi√≥n.

#### üöó Aplicaciones en Autom√≥viles Aut√≥nomos
Los veh√≠culos aut√≥nomos utilizan sistemas de detecci√≥n de objetos para identificar peatones, otros veh√≠culos, se√±ales de tr√°fico y obst√°culos en la carretera. Esto es crucial para la navegaci√≥n segura y eficiente, reduciendo el riesgo de accidentes.

#### üèóÔ∏è Aplicaciones en la Construcci√≥n
En la industria de la construcci√≥n, la detecci√≥n de objetos se usa para monitorear el progreso de proyectos, asegurar la seguridad de los trabajadores y gestionar recursos de manera eficiente. Las c√°maras equipadas con IA pueden identificar √°reas peligrosas y alertar a los supervisores en tiempo real.

#### üõí Aplicaciones en el Retail
En el comercio minorista, la detecci√≥n de objetos se utiliza para el control de inventarios, la prevenci√≥n de p√©rdidas y la mejora de la experiencia del cliente. Los sistemas inteligentes pueden rastrear productos, detectar robos y ofrecer recomendaciones personalizadas a los compradores.

#### üå± Aplicaciones en la Agricultura
La detecci√≥n de objetos en la agricultura ayuda a monitorear el crecimiento de cultivos, identificar plagas y enfermedades, y optimizar el uso de recursos como agua y fertilizantes. Esto mejora la eficiencia y sostenibilidad de las pr√°cticas agr√≠colas.

---
# D√≠a35
---
## T√©cnicas de Mejora de Precisi√≥n en Detecci√≥n de Objetos üéØüîç**


#### üìà Uso de M√∫ltiples Escalas
Una t√©cnica efectiva para mejorar la precisi√≥n es el uso de m√∫ltiples escalas. Al entrenar y evaluar los modelos en diferentes resoluciones de imagen, podemos captar mejor los objetos de distintos tama√±os y mejorar la detecci√≥n en escenarios variados.

#### üß© Aumento de Datos
El aumento de datos (data augmentation) implica aplicar transformaciones como rotaciones, recortes, cambios de brillo y contraste, y m√°s a las im√°genes de entrenamiento. Esto ayuda a los modelos a generalizar mejor y a ser m√°s robustos frente a variaciones en los datos de entrada. Ultralytics facilita el aumento de datos a trav√©s de configuraciones sencillas en sus scripts de entrenamiento.

#### üîÑ Ajuste Fino de Modelos Preentrenados
El ajuste fino (fine-tuning) de modelos preentrenados es una forma poderosa de mejorar la precisi√≥n. Podemos empezar con un modelo preentrenado en un gran conjunto de datos y ajustarlo con nuestros datos espec√≠ficos. Ultralytics permite la f√°cil configuraci√≥n y ajuste fino de modelos como YOLOv5 y YOLOv8 a trav√©s de su interfaz intuitiva y comandos accesibles.

#### ‚öñÔ∏è Equilibrio de Clases
En conjuntos de datos desbalanceados, algunas clases pueden estar subrepresentadas, lo que afecta la precisi√≥n. Podemos aplicar t√©cnicas como el re-muestreo (over-sampling y under-sampling) o la ponderaci√≥n de p√©rdida para equilibrar las clases y mejorar el rendimiento del modelo. Ultralytics proporciona opciones para manejar desequilibrios de clase en sus configuraciones de entrenamiento.

#### üìä Evaluaci√≥n y M√©tricas
Es crucial usar las m√©tricas adecuadas para evaluar el desempe√±o de nuestros modelos. M√©tricas como precisi√≥n (precision), recall, F1-score y mean Average Precision (mAP) nos proporcionan una visi√≥n completa de c√≥mo est√° funcionando nuestro modelo y d√≥nde podemos mejorar. Las herramientas de Ultralytics incluyen opciones detalladas de evaluaci√≥n para obtener estos indicadores clave.

#### üí° Implementaci√≥n de Ensembles
Los modelos de ensembles combinan las predicciones de m√∫ltiples modelos para obtener un resultado final m√°s preciso. Al promediar o votar entre las predicciones, podemos reducir el sesgo y la varianza, mejorando la precisi√≥n general. Ultralytics permite la configuraci√≥n de ensembles de manera eficiente, facilitando la implementaci√≥n de esta t√©cnica avanzada.

#### üîß Herramientas de Ultralytics
Ultralytics ofrece una serie de herramientas y configuraciones que hacen que el proceso de entrenamiento, ajuste fino y evaluaci√≥n de modelos de detecci√≥n de objetos sea m√°s accesible y eficiente. Entre las caracter√≠sticas destacadas se incluyen:

- **Configuraciones de entrenamiento:** Ajustes sencillos para hiperpar√°metros y estrategias de aumento de datos.
- **Modelos preentrenados:** Acceso a una variedad de modelos preentrenados, listos para ajuste fino.
- **Evaluaci√≥n avanzada:** M√©tricas detalladas y an√°lisis de desempe√±o para una comprensi√≥n profunda del modelo.

Para m√°s detalles sobre estas herramientas, visita la [documentaci√≥n de Ultralytics](https://docs.ultralytics.com/es/modes/train/#what-are-the-common-training-settings-and-how-do-i-configure-them).

---
# D√≠a36
---
### Segmentaci√≥n de Im√°genes con Redes Neuronales Convolucionales üñºÔ∏èüß†**

#### üåü ¬øQu√© es la Segmentaci√≥n de Im√°genes?
La segmentaci√≥n de im√°genes es una t√©cnica en visi√≥n por computadora que divide una imagen en segmentos significativos para facilitar su an√°lisis. A diferencia de la clasificaci√≥n de im√°genes, que asigna una etiqueta a toda la imagen, la segmentaci√≥n de im√°genes asigna una etiqueta a cada p√≠xel, permitiendo una comprensi√≥n m√°s detallada y precisa del contenido visual.

#### üß© Tipos de Segmentaci√≥n de Im√°genes
1. **Segmentaci√≥n Sem√°ntica:** Asigna una etiqueta a cada p√≠xel basado en la clase a la que pertenece. Por ejemplo, en una imagen de una calle, todos los p√≠xeles pertenecientes a "coches" se etiquetan como tal, sin distinguir entre coches individuales.
2. **Segmentaci√≥n de Instancias:** No solo clasifica cada p√≠xel sino que tambi√©n distingue entre diferentes instancias de la misma clase. Siguiendo el ejemplo anterior, no solo se etiqueta "coches", sino que se distingue entre cada coche individual.
3. **Segmentaci√≥n Pan√≥ptica:** Combina la segmentaci√≥n sem√°ntica y de instancias para ofrecer una vista completa, etiquetando tanto las clases como las instancias √∫nicas.

#### üõ†Ô∏è Herramientas y Funciones de Ultralytics para Segmentaci√≥n de Im√°genes
Ultralytics proporciona herramientas poderosas para implementar y entrenar modelos de segmentaci√≥n de im√°genes. Aqu√≠ hay algunas caracter√≠sticas clave:

- **Modelos Preentrenados:** Utiliza modelos como YOLOv5 y YOLOv8, que ofrecen capacidades avanzadas de segmentaci√≥n.
- **Configuraciones de Entrenamiento:** Ajusta par√°metros como tasa de aprendizaje, √©pocas, y aumento de datos para optimizar el rendimiento.
- **Aumento de Datos:** Aplica t√©cnicas de data augmentation espec√≠ficas para segmentaci√≥n, como rotaciones, recortes, y ajustes de brillo.
- **Evaluaci√≥n Avanzada:** Usa m√©tricas especializadas para evaluar el rendimiento de los modelos de segmentaci√≥n, como Intersection over Union (IoU) y mean Average Precision (mAP).


---
# D√≠a37
---
## Implementaci√≥n de Segmentaci√≥n de Im√°genes con YOLO y Ultralytics - Demo Pr√°ctica üõ†Ô∏èüìä**

### üîß Herramientas Necesarias:
1. **Ultralytics YOLOv8:** Nuestro modelo de elecci√≥n para la segmentaci√≥n.
2. **Dataset:** Un conjunto de datos adecuado para segmentaci√≥n (puede ser COCO, Pascal VOC, etc.).
3. **Entorno de Desarrollo:** Puede ser Jupyter Notebook o cualquier IDE que prefieras.

### üìö Paso a Paso:

1. **Preparaci√≥n del Entorno:**
   - Aseg√∫rate de tener Python y las bibliotecas necesarias instaladas.
   - Clona el repositorio de Ultralytics y navega a la carpeta correspondiente.
   - Instala las dependencias:
     ```bash
     pip install ultralytics
     ```

2. **Carga del Dataset:**
   - Descarga y prepara el dataset.
   - Configura las rutas en el archivo de configuraci√≥n de Ultralytics.

3. **Configuraci√≥n del Modelo:**
   - Selecciona y configura el modelo YOLOv8 para segmentaci√≥n.
   - Ajusta los par√°metros de entrenamiento, como la tasa de aprendizaje y el n√∫mero de √©pocas.

4. **Entrenamiento del Modelo:**
   - Inicia el entrenamiento utilizando el script de Ultralytics:
     ```python
     from ultralytics import YOLO

     # Cargar el modelo
     model = YOLO('yolov8-seg.pt')

     # Entrenar el modelo
     model.train(data='path/to/dataset', epochs=50, batch=16)
     ```

5. **Evaluaci√≥n y Resultados:**
   - Despu√©s del entrenamiento, eval√∫a el modelo usando el conjunto de datos de validaci√≥n.
   - Visualiza los resultados de la segmentaci√≥n:
     ```python
     # Evaluar el modelo
     results = model.val()

     # Mostrar los resultados
     results.show()
     ```

6. **Implementaci√≥n y Demo:**
   - Usa el modelo entrenado para realizar predicciones en im√°genes nuevas.
   - Muestra los resultados de la segmentaci√≥n en una demo pr√°ctica.
     ```python
     # Realizar inferencia en una nueva imagen
     results = model.predict('path/to/image.jpg')

     # Mostrar el resultado de la segmentaci√≥n
     results.show()
     ```

### Recursos Adicionales:
- [Documentaci√≥n de Ultralytics](https://docs.ultralytics.com/es/modes/train/#what-are-the-common-training-settings-and-how-do-i-configure-them)
- [Repositorio de YOLOv8 en GitHub](https://github.com/ultralytics/yolov8)

---
# D√≠a38
---
## Introducci√≥n a los Modelos Preentrenados üìöüí°


### ¬øQu√© son los Modelos Preentrenados? ü§î
Los modelos preentrenados son redes neuronales que han sido previamente entrenadas en grandes conjuntos de datos y est√°n listos para ser reutilizados en diferentes tareas sin necesidad de entrenamiento desde cero.



### Beneficios de Utilizar Modelos Preentrenados üåü
- **Ahorro de Tiempo y Recursos**: No necesitas entrenar modelos desde cero, lo que ahorra tiempo y recursos computacionales.
- **Mejor Rendimiento**: Aprovechan el conocimiento adquirido de vastos conjuntos de datos, mejorando el rendimiento en tareas espec√≠ficas.
- **F√°cil de Personalizar**: Puedes ajustar y adaptar estos modelos a tus necesidades espec√≠ficas mediante fine-tuning.

### Ejemplos Populares üìà
- **ResNet**: Excelente para tareas de clasificaci√≥n de im√°genes.
- **BERT**: Popular en procesamiento del lenguaje natural (NLP).
- **YOLO**: Usado para detecci√≥n de objetos en tiempo real.



### Recursos para Encontrar Modelos Preentrenados üõ†Ô∏è
- **[Hugging Face](https://huggingface.co/models)**: Amplia biblioteca de modelos de NLP.
- **[TensorFlow Hub](https://tfhub.dev/)**: Gran colecci√≥n de modelos para visi√≥n por computadora y m√°s.


---
# D√≠a39
# D√≠a40
# D√≠a41
# D√≠a42
# D√≠a43
# D√≠a44
# D√≠a45
# D√≠a46
# D√≠a47
# D√≠a48
# D√≠a49
# D√≠a50
# D√≠a51
# D√≠a52
# D√≠a53
# D√≠a54
# D√≠a55
# D√≠a56
# D√≠a57
# D√≠a58
# D√≠a59
# D√≠a60
# D√≠a61
# D√≠a62
# D√≠a63
# D√≠a64
# D√≠a65
# D√≠a66
# D√≠a67
# D√≠a68
# D√≠a69
# D√≠a70
# D√≠a71
# D√≠a72
# D√≠a73
# D√≠a74
# D√≠a75
# D√≠a76
# D√≠a77
# D√≠a78
# D√≠a79
# D√≠a80
# D√≠a81
# D√≠a82
# D√≠a83
# D√≠a84
# D√≠a85
# D√≠a86
# D√≠a87
# D√≠a88
# D√≠a89
# D√≠a90
# D√≠a91
# D√≠a92
# D√≠a93
# D√≠a94
# D√≠a95
# D√≠a96
# D√≠a97
# D√≠a98
# D√≠a99
# D√≠a100
